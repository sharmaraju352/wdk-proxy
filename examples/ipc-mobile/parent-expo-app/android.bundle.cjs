module.exports = "30477\n{\"version\":0,\"id\":\"e27a8d7f90ee9a8a203b2e3729ebd64b8432e1c5f49d17bbe6eff6c9595f0834\",\"main\":\"/examples/ipc-mobile/child.js\",\"imports\":{},\"resolutions\":{\"/examples/ipc-mobile/child.js\":{\"#package\":\"/package.json\",\"../../proxy\":\"/proxy/index.js\",\"../../transport\":\"/transport/index.js\",\"events\":\"/node_modules/events/index.js\"},\"/node_modules/b4a/index.js\":{\"#package\":\"/node_modules/b4a/package.json\"},\"/node_modules/b4a/package.json\":{},\"/node_modules/bare-crypto/binding.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\".\":\"linked:libbare-crypto.1.4.0.so\"},\"/node_modules/bare-crypto/index.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\"./binding\":\"/node_modules/bare-crypto/binding.js\",\"./lib/constants\":\"/node_modules/bare-crypto/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-crypto/lib/errors.js\",\"./web\":\"/node_modules/bare-crypto/web.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-crypto/lib/constants.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\"../binding\":\"/node_modules/bare-crypto/binding.js\"},\"/node_modules/bare-crypto/lib/errors.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\"},\"/node_modules/bare-crypto/package.json\":{},\"/node_modules/bare-crypto/web.js\":{\"#package\":\"/node_modules/bare-crypto/package.json\",\".\":\"/node_modules/bare-crypto/index.js\"},\"/node_modules/bare-dns/binding.js\":{\"#package\":\"/node_modules/bare-dns/package.json\",\".\":\"linked:libbare-dns.2.0.4.so\"},\"/node_modules/bare-dns/index.js\":{\"#package\":\"/node_modules/bare-dns/package.json\",\"./binding\":\"/node_modules/bare-dns/binding.js\"},\"/node_modules/bare-dns/package.json\":{},\"/node_modules/bare-events/index.js\":{\"#package\":\"/node_modules/bare-events/package.json\",\"./lib/errors\":\"/node_modules/bare-events/lib/errors.js\"},\"/node_modules/bare-events/lib/errors.js\":{\"#package\":\"/node_modules/bare-events/package.json\"},\"/node_modules/bare-events/package.json\":{},\"/node_modules/bare-fetch/index.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\",\"./lib/errors\":\"/node_modules/bare-fetch/lib/errors.js\",\"./lib/headers\":\"/node_modules/bare-fetch/lib/headers.js\",\"./lib/request\":\"/node_modules/bare-fetch/lib/request.js\",\"./lib/response\":\"/node_modules/bare-fetch/lib/response.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-https\":\"/node_modules/bare-https/index.js\",\"bare-stream/web\":\"/node_modules/bare-stream/web.js\"},\"/node_modules/bare-fetch/lib/body.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\",\"./errors\":\"/node_modules/bare-fetch/lib/errors.js\",\"bare-stream/web\":\"/node_modules/bare-stream/web.js\"},\"/node_modules/bare-fetch/lib/errors.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\"},\"/node_modules/bare-fetch/lib/headers.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\"},\"/node_modules/bare-fetch/lib/request.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\",\"./body\":\"/node_modules/bare-fetch/lib/body.js\",\"./errors\":\"/node_modules/bare-fetch/lib/errors.js\",\"./headers\":\"/node_modules/bare-fetch/lib/headers.js\"},\"/node_modules/bare-fetch/lib/response.js\":{\"#package\":\"/node_modules/bare-fetch/package.json\",\"./body\":\"/node_modules/bare-fetch/lib/body.js\",\"./headers\":\"/node_modules/bare-fetch/lib/headers.js\"},\"/node_modules/bare-fetch/package.json\":{},\"/node_modules/bare-http1/index.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./lib/agent\":\"/node_modules/bare-http1/lib/agent.js\",\"./lib/client-connection\":\"/node_modules/bare-http1/lib/client-connection.js\",\"./lib/client-request\":\"/node_modules/bare-http1/lib/client-request.js\",\"./lib/constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./lib/incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\",\"./lib/outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\",\"./lib/server\":\"/node_modules/bare-http1/lib/server.js\",\"./lib/server-connection\":\"/node_modules/bare-http1/lib/server-connection.js\",\"./lib/server-response\":\"/node_modules/bare-http1/lib/server-response.js\"},\"/node_modules/bare-http1/lib/agent.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./client-connection\":\"/node_modules/bare-http1/lib/client-connection.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/lib/client-connection.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./errors\":\"/node_modules/bare-http1/lib/errors.js\",\"./incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\"},\"/node_modules/bare-http1/lib/client-request.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./agent\":\"/node_modules/bare-http1/lib/agent.js\",\"./outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/bare-http1/lib/constants.js\":{\"#package\":\"/node_modules/bare-http1/package.json\"},\"/node_modules/bare-http1/lib/errors.js\":{\"#package\":\"/node_modules/bare-http1/package.json\"},\"/node_modules/bare-http1/lib/incoming-message.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-http1/lib/outgoing-message.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./errors\":\"/node_modules/bare-http1/lib/errors.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-http1/lib/server-connection.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./incoming-message\":\"/node_modules/bare-http1/lib/incoming-message.js\",\"./server-response\":\"/node_modules/bare-http1/lib/server-response.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/lib/server-response.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./constants\":\"/node_modules/bare-http1/lib/constants.js\",\"./outgoing-message\":\"/node_modules/bare-http1/lib/outgoing-message.js\"},\"/node_modules/bare-http1/lib/server.js\":{\"#package\":\"/node_modules/bare-http1/package.json\",\"./server-connection\":\"/node_modules/bare-http1/lib/server-connection.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-http1/package.json\":{},\"/node_modules/bare-https/index.js\":{\"#package\":\"/node_modules/bare-https/package.json\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\",\"bare-tls\":\"/node_modules/bare-tls/index.js\"},\"/node_modules/bare-https/package.json\":{},\"/node_modules/bare-net/index.js\":{\"#package\":\"/node_modules/bare-net/package.json\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-pipe\":\"/node_modules/bare-pipe/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\",\"bare-tcp\":\"/node_modules/bare-tcp/index.js\"},\"/node_modules/bare-net/package.json\":{},\"/node_modules/bare-os/binding.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\".\":\"linked:libbare-os.3.5.1.so\"},\"/node_modules/bare-os/index.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\"./binding\":\"/node_modules/bare-os/binding.js\",\"./lib/constants\":\"/node_modules/bare-os/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-os/lib/errors.js\"},\"/node_modules/bare-os/lib/constants.js\":{\"#package\":\"/node_modules/bare-os/package.json\",\"../binding\":\"/node_modules/bare-os/binding.js\"},\"/node_modules/bare-os/lib/errors.js\":{\"#package\":\"/node_modules/bare-os/package.json\"},\"/node_modules/bare-os/package.json\":{},\"/node_modules/bare-path/index.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./lib/posix\":\"/node_modules/bare-path/lib/posix.js\",\"./lib/win32\":\"/node_modules/bare-path/lib/win32.js\"},\"/node_modules/bare-path/lib/constants.js\":{\"#package\":\"/node_modules/bare-path/package.json\"},\"/node_modules/bare-path/lib/posix.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\",\"./shared\":\"/node_modules/bare-path/lib/shared.js\",\"./win32\":\"/node_modules/bare-path/lib/win32.js\",\"bare-os\":\"/node_modules/bare-os/index.js\"},\"/node_modules/bare-path/lib/shared.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\"},\"/node_modules/bare-path/lib/win32.js\":{\"#package\":\"/node_modules/bare-path/package.json\",\"./constants\":\"/node_modules/bare-path/lib/constants.js\",\"./posix\":\"/node_modules/bare-path/lib/posix.js\",\"./shared\":\"/node_modules/bare-path/lib/shared.js\",\"bare-os\":\"/node_modules/bare-os/index.js\"},\"/node_modules/bare-path/package.json\":{},\"/node_modules/bare-pipe/binding.js\":{\"#package\":\"/node_modules/bare-pipe/package.json\",\".\":\"linked:libbare-pipe.4.0.4.so\"},\"/node_modules/bare-pipe/index.js\":{\"#package\":\"/node_modules/bare-pipe/package.json\",\"./binding\":\"/node_modules/bare-pipe/binding.js\",\"./lib/constants\":\"/node_modules/bare-pipe/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-pipe/lib/errors.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-pipe/lib/constants.js\":{\"#package\":\"/node_modules/bare-pipe/package.json\"},\"/node_modules/bare-pipe/lib/errors.js\":{\"#package\":\"/node_modules/bare-pipe/package.json\"},\"/node_modules/bare-pipe/package.json\":{},\"/node_modules/bare-stream/index.js\":{\"#package\":\"/node_modules/bare-stream/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/bare-stream/package.json\":{},\"/node_modules/bare-stream/web.js\":{\"#package\":\"/node_modules/bare-stream/package.json\",\"streamx\":\"/node_modules/streamx/index.js\"},\"/node_modules/bare-tcp/binding.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\",\".\":\"linked:libbare-tcp.2.0.3.so\"},\"/node_modules/bare-tcp/index.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\",\"./binding\":\"/node_modules/bare-tcp/binding.js\",\"./lib/constants\":\"/node_modules/bare-tcp/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-tcp/lib/errors.js\",\"./lib/ip\":\"/node_modules/bare-tcp/lib/ip.js\",\"bare-dns\":\"/node_modules/bare-dns/index.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-tcp/lib/constants.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/lib/errors.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/lib/ip.js\":{\"#package\":\"/node_modules/bare-tcp/package.json\"},\"/node_modules/bare-tcp/package.json\":{},\"/node_modules/bare-tls/binding.js\":{\"#package\":\"/node_modules/bare-tls/package.json\",\".\":\"linked:libbare-tls.2.0.0.so\"},\"/node_modules/bare-tls/index.js\":{\"#package\":\"/node_modules/bare-tls/package.json\",\"./binding\":\"/node_modules/bare-tls/binding.js\",\"./lib/constants\":\"/node_modules/bare-tls/lib/constants.js\",\"./lib/errors\":\"/node_modules/bare-tls/lib/errors.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-tls/lib/constants.js\":{\"#package\":\"/node_modules/bare-tls/package.json\"},\"/node_modules/bare-tls/lib/errors.js\":{\"#package\":\"/node_modules/bare-tls/package.json\"},\"/node_modules/bare-tls/package.json\":{},\"/node_modules/bare-url/binding.js\":{\"#package\":\"/node_modules/bare-url/package.json\",\".\":\"linked:libbare-url.2.1.3.so\"},\"/node_modules/bare-url/index.js\":{\"#package\":\"/node_modules/bare-url/package.json\",\"./binding\":\"/node_modules/bare-url/binding.js\",\"./lib/errors\":\"/node_modules/bare-url/lib/errors.js\",\"bare-path\":\"/node_modules/bare-path/index.js\"},\"/node_modules/bare-url/lib/errors.js\":{\"#package\":\"/node_modules/bare-url/package.json\"},\"/node_modules/bare-url/package.json\":{},\"/node_modules/bare-ws/index.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./lib/server\":\"/node_modules/bare-ws/lib/server.js\",\"./lib/socket\":\"/node_modules/bare-ws/lib/socket.js\"},\"/node_modules/bare-ws/lib/constants.js\":{\"#package\":\"/node_modules/bare-ws/package.json\"},\"/node_modules/bare-ws/lib/errors.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\"},\"/node_modules/bare-ws/lib/frame.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\"},\"/node_modules/bare-ws/lib/server.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"./socket\":\"/node_modules/bare-ws/lib/socket.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\",\"bare-events\":\"/node_modules/bare-events/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-https\":\"/node_modules/bare-https/index.js\"},\"/node_modules/bare-ws/lib/socket.js\":{\"#package\":\"/node_modules/bare-ws/package.json\",\"./constants\":\"/node_modules/bare-ws/lib/constants.js\",\"./errors\":\"/node_modules/bare-ws/lib/errors.js\",\"./frame\":\"/node_modules/bare-ws/lib/frame.js\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"bare-https\":\"/node_modules/bare-https/index.js\",\"bare-stream\":\"/node_modules/bare-stream/index.js\"},\"/node_modules/bare-ws/package.json\":{},\"/node_modules/crypto/index.js\":{\"#package\":\"/node_modules/crypto/package.json\",\"bare-crypto\":\"/node_modules/bare-crypto/index.js\"},\"/node_modules/crypto/package.json\":{},\"/node_modules/events/index.js\":{\"#package\":\"/node_modules/events/package.json\",\"bare-events\":\"/node_modules/bare-events/index.js\"},\"/node_modules/events/package.json\":{},\"/node_modules/fast-fifo/fixed-size.js\":{\"#package\":\"/node_modules/fast-fifo/package.json\"},\"/node_modules/fast-fifo/index.js\":{\"#package\":\"/node_modules/fast-fifo/package.json\",\"./fixed-size\":\"/node_modules/fast-fifo/fixed-size.js\"},\"/node_modules/fast-fifo/package.json\":{},\"/node_modules/streamx/index.js\":{\"#package\":\"/node_modules/streamx/package.json\",\"events\":\"/node_modules/bare-events/index.js\",\"fast-fifo\":\"/node_modules/fast-fifo/index.js\",\"text-decoder\":\"/node_modules/text-decoder/index.js\"},\"/node_modules/streamx/package.json\":{},\"/node_modules/text-decoder/index.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"./lib/pass-through-decoder\":\"/node_modules/text-decoder/lib/pass-through-decoder.js\",\"./lib/utf8-decoder\":\"/node_modules/text-decoder/lib/utf8-decoder.js\"},\"/node_modules/text-decoder/lib/pass-through-decoder.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/text-decoder/lib/utf8-decoder.js\":{\"#package\":\"/node_modules/text-decoder/package.json\",\"b4a\":\"/node_modules/b4a/index.js\"},\"/node_modules/text-decoder/package.json\":{},\"/node_modules/url/index.js\":{\"#package\":\"/node_modules/url/package.json\",\"bare-url\":\"/node_modules/bare-url/index.js\"},\"/node_modules/url/package.json\":{},\"/node_modules/uuid/dist/cjs/index.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./max.js\":\"/node_modules/uuid/dist/cjs/max.js\",\"./nil.js\":\"/node_modules/uuid/dist/cjs/nil.js\",\"./parse.js\":\"/node_modules/uuid/dist/cjs/parse.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\",\"./v1.js\":\"/node_modules/uuid/dist/cjs/v1.js\",\"./v1ToV6.js\":\"/node_modules/uuid/dist/cjs/v1ToV6.js\",\"./v3.js\":\"/node_modules/uuid/dist/cjs/v3.js\",\"./v4.js\":\"/node_modules/uuid/dist/cjs/v4.js\",\"./v5.js\":\"/node_modules/uuid/dist/cjs/v5.js\",\"./v6.js\":\"/node_modules/uuid/dist/cjs/v6.js\",\"./v6ToV1.js\":\"/node_modules/uuid/dist/cjs/v6ToV1.js\",\"./v7.js\":\"/node_modules/uuid/dist/cjs/v7.js\",\"./validate.js\":\"/node_modules/uuid/dist/cjs/validate.js\",\"./version.js\":\"/node_modules/uuid/dist/cjs/version.js\"},\"/node_modules/uuid/dist/cjs/max.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\"},\"/node_modules/uuid/dist/cjs/md5.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"crypto\":\"/node_modules/crypto/index.js\"},\"/node_modules/uuid/dist/cjs/native.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"crypto\":\"/node_modules/crypto/index.js\"},\"/node_modules/uuid/dist/cjs/nil.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\"},\"/node_modules/uuid/dist/cjs/package.json\":{},\"/node_modules/uuid/dist/cjs/parse.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./validate.js\":\"/node_modules/uuid/dist/cjs/validate.js\"},\"/node_modules/uuid/dist/cjs/regex.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\"},\"/node_modules/uuid/dist/cjs/rng.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"crypto\":\"/node_modules/crypto/index.js\"},\"/node_modules/uuid/dist/cjs/sha1.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"crypto\":\"/node_modules/crypto/index.js\"},\"/node_modules/uuid/dist/cjs/stringify.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./validate.js\":\"/node_modules/uuid/dist/cjs/validate.js\"},\"/node_modules/uuid/dist/cjs/v1.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./rng.js\":\"/node_modules/uuid/dist/cjs/rng.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/v1ToV6.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./parse.js\":\"/node_modules/uuid/dist/cjs/parse.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/v3.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./md5.js\":\"/node_modules/uuid/dist/cjs/md5.js\",\"./v35.js\":\"/node_modules/uuid/dist/cjs/v35.js\"},\"/node_modules/uuid/dist/cjs/v35.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./parse.js\":\"/node_modules/uuid/dist/cjs/parse.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/v4.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./native.js\":\"/node_modules/uuid/dist/cjs/native.js\",\"./rng.js\":\"/node_modules/uuid/dist/cjs/rng.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/v5.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./sha1.js\":\"/node_modules/uuid/dist/cjs/sha1.js\",\"./v35.js\":\"/node_modules/uuid/dist/cjs/v35.js\"},\"/node_modules/uuid/dist/cjs/v6.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\",\"./v1.js\":\"/node_modules/uuid/dist/cjs/v1.js\",\"./v1ToV6.js\":\"/node_modules/uuid/dist/cjs/v1ToV6.js\"},\"/node_modules/uuid/dist/cjs/v6ToV1.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./parse.js\":\"/node_modules/uuid/dist/cjs/parse.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/v7.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./rng.js\":\"/node_modules/uuid/dist/cjs/rng.js\",\"./stringify.js\":\"/node_modules/uuid/dist/cjs/stringify.js\"},\"/node_modules/uuid/dist/cjs/validate.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./regex.js\":\"/node_modules/uuid/dist/cjs/regex.js\"},\"/node_modules/uuid/dist/cjs/version.js\":{\"#package\":\"/node_modules/uuid/dist/cjs/package.json\",\"./validate.js\":\"/node_modules/uuid/dist/cjs/validate.js\"},\"/package.json\":{},\"/proxy/ProxyClient.js\":{\"#package\":\"/package.json\",\"events\":\"/node_modules/events/index.js\"},\"/proxy/ProxyServer.js\":{\"#package\":\"/package.json\"},\"/proxy/index.js\":{\"#package\":\"/package.json\",\"./ProxyClient\":\"/proxy/ProxyClient.js\",\"./ProxyServer\":\"/proxy/ProxyServer.js\"},\"/transport/BaseTransport.js\":{\"#package\":\"/package.json\"},\"/transport/DesktopIPCTransport.js\":{\"#package\":\"/package.json\",\"./BaseTransport\":\"/transport/BaseTransport.js\",\"bare-net\":\"/node_modules/bare-net/index.js\"},\"/transport/HTTPTransport.js\":{\"#package\":\"/package.json\",\"./BaseTransport\":\"/transport/BaseTransport.js\",\"bare-fetch\":\"/node_modules/bare-fetch/index.js\",\"bare-http1\":\"/node_modules/bare-http1/index.js\",\"url\":\"/node_modules/url/index.js\",\"uuid\":\"/node_modules/uuid/dist/cjs/index.js\"},\"/transport/MobileIPCTransport.js\":{\"#package\":\"/package.json\",\"./BaseTransport\":\"/transport/BaseTransport.js\"},\"/transport/WebSocketTransport.js\":{\"#package\":\"/package.json\",\"./BaseTransport\":\"/transport/BaseTransport.js\",\"bare-ws\":\"/node_modules/bare-ws/index.js\"},\"/transport/index.js\":{\"#package\":\"/package.json\",\"./BaseTransport\":\"/transport/BaseTransport.js\",\"./DesktopIPCTransport\":\"/transport/DesktopIPCTransport.js\",\"./HTTPTransport\":\"/transport/HTTPTransport.js\",\"./MobileIPCTransport\":\"/transport/MobileIPCTransport.js\",\"./WebSocketTransport\":\"/transport/WebSocketTransport.js\"}},\"addons\":[\"linked:libbare-crypto.1.4.0.so\",\"linked:libbare-dns.2.0.4.so\",\"linked:libbare-os.3.5.1.so\",\"linked:libbare-pipe.4.0.4.so\",\"linked:libbare-tcp.2.0.3.so\",\"linked:libbare-tls.2.0.0.so\",\"linked:libbare-url.2.1.3.so\"],\"assets\":[],\"files\":{\"/examples/ipc-mobile/child.js\":{\"offset\":0,\"length\":1598,\"mode\":420},\"/node_modules/b4a/index.js\":{\"offset\":1598,\"length\":4092,\"mode\":420},\"/node_modules/b4a/package.json\":{\"offset\":5690,\"length\":701,\"mode\":420},\"/node_modules/bare-crypto/binding.js\":{\"offset\":6391,\"length\":33,\"mode\":420},\"/node_modules/bare-crypto/index.js\":{\"offset\":6424,\"length\":2798,\"mode\":420},\"/node_modules/bare-crypto/lib/constants.js\":{\"offset\":9222,\"length\":211,\"mode\":420},\"/node_modules/bare-crypto/lib/errors.js\":{\"offset\":9433,\"length\":450,\"mode\":420},\"/node_modules/bare-crypto/package.json\":{\"offset\":9883,\"length\":1349,\"mode\":420},\"/node_modules/bare-crypto/web.js\":{\"offset\":11232,\"length\":195,\"mode\":420},\"/node_modules/bare-dns/binding.js\":{\"offset\":11427,\"length\":33,\"mode\":420},\"/node_modules/bare-dns/index.js\":{\"offset\":11460,\"length\":895,\"mode\":420},\"/node_modules/bare-dns/package.json\":{\"offset\":12355,\"length\":939,\"mode\":420},\"/node_modules/bare-events/index.js\":{\"offset\":13294,\"length\":6999,\"mode\":420},\"/node_modules/bare-events/lib/errors.js\":{\"offset\":20293,\"length\":711,\"mode\":420},\"/node_modules/bare-events/package.json\":{\"offset\":21004,\"length\":944,\"mode\":420},\"/node_modules/bare-fetch/index.js\":{\"offset\":21948,\"length\":2484,\"mode\":420},\"/node_modules/bare-fetch/lib/body.js\":{\"offset\":24432,\"length\":1846,\"mode\":420},\"/node_modules/bare-fetch/lib/errors.js\":{\"offset\":26278,\"length\":909,\"mode\":420},\"/node_modules/bare-fetch/lib/headers.js\":{\"offset\":27187,\"length\":1480,\"mode\":420},\"/node_modules/bare-fetch/lib/request.js\":{\"offset\":28667,\"length\":879,\"mode\":420},\"/node_modules/bare-fetch/lib/response.js\":{\"offset\":29546,\"length\":1190,\"mode\":420},\"/node_modules/bare-fetch/package.json\":{\"offset\":30736,\"length\":1084,\"mode\":420},\"/node_modules/bare-http1/index.js\":{\"offset\":31820,\"length\":1917,\"mode\":420},\"/node_modules/bare-http1/lib/agent.js\":{\"offset\":33737,\"length\":2834,\"mode\":420},\"/node_modules/bare-http1/lib/client-connection.js\":{\"offset\":36571,\"length\":6174,\"mode\":420},\"/node_modules/bare-http1/lib/client-request.js\":{\"offset\":42745,\"length\":2541,\"mode\":420},\"/node_modules/bare-http1/lib/constants.js\":{\"offset\":45286,\"length\":2121,\"mode\":420},\"/node_modules/bare-http1/lib/errors.js\":{\"offset\":47407,\"length\":545,\"mode\":420},\"/node_modules/bare-http1/lib/incoming-message.js\":{\"offset\":47952,\"length\":937,\"mode\":420},\"/node_modules/bare-http1/lib/outgoing-message.js\":{\"offset\":48889,\"length\":1023,\"mode\":420},\"/node_modules/bare-http1/lib/server-connection.js\":{\"offset\":49912,\"length\":6546,\"mode\":420},\"/node_modules/bare-http1/lib/server-response.js\":{\"offset\":56458,\"length\":2760,\"mode\":420},\"/node_modules/bare-http1/lib/server.js\":{\"offset\":59218,\"length\":956,\"mode\":420},\"/node_modules/bare-http1/package.json\":{\"offset\":60174,\"length\":867,\"mode\":420},\"/node_modules/bare-https/index.js\":{\"offset\":61041,\"length\":3226,\"mode\":420},\"/node_modules/bare-https/package.json\":{\"offset\":64267,\"length\":828,\"mode\":420},\"/node_modules/bare-net/index.js\":{\"offset\":65095,\"length\":6915,\"mode\":420},\"/node_modules/bare-net/package.json\":{\"offset\":72010,\"length\":844,\"mode\":420},\"/node_modules/bare-os/binding.js\":{\"offset\":72854,\"length\":33,\"mode\":420},\"/node_modules/bare-os/index.js\":{\"offset\":72887,\"length\":2397,\"mode\":420},\"/node_modules/bare-os/lib/constants.js\":{\"offset\":75284,\"length\":113,\"mode\":420},\"/node_modules/bare-os/lib/errors.js\":{\"offset\":75397,\"length\":479,\"mode\":420},\"/node_modules/bare-os/package.json\":{\"offset\":75876,\"length\":1023,\"mode\":420},\"/node_modules/bare-path/index.js\":{\"offset\":76899,\"length\":306,\"mode\":420},\"/node_modules/bare-path/lib/constants.js\":{\"offset\":77205,\"length\":247,\"mode\":420},\"/node_modules/bare-path/lib/posix.js\":{\"offset\":77452,\"length\":5991,\"mode\":420},\"/node_modules/bare-path/lib/shared.js\":{\"offset\":83443,\"length\":1888,\"mode\":420},\"/node_modules/bare-path/lib/win32.js\":{\"offset\":85331,\"length\":13427,\"mode\":420},\"/node_modules/bare-path/package.json\":{\"offset\":98758,\"length\":796,\"mode\":420},\"/node_modules/bare-pipe/binding.js\":{\"offset\":99554,\"length\":33,\"mode\":420},\"/node_modules/bare-pipe/index.js\":{\"offset\":99587,\"length\":10652,\"mode\":420},\"/node_modules/bare-pipe/lib/constants.js\":{\"offset\":110239,\"length\":188,\"mode\":420},\"/node_modules/bare-pipe/lib/errors.js\":{\"offset\":110427,\"length\":711,\"mode\":420},\"/node_modules/bare-pipe/package.json\":{\"offset\":111138,\"length\":1254,\"mode\":420},\"/node_modules/bare-stream/index.js\":{\"offset\":112392,\"length\":7649,\"mode\":420},\"/node_modules/bare-stream/package.json\":{\"offset\":120041,\"length\":1237,\"mode\":420},\"/node_modules/bare-stream/web.js\":{\"offset\":121278,\"length\":4533,\"mode\":420},\"/node_modules/bare-tcp/binding.js\":{\"offset\":125811,\"length\":33,\"mode\":420},\"/node_modules/bare-tcp/index.js\":{\"offset\":125844,\"length\":12375,\"mode\":420},\"/node_modules/bare-tcp/lib/constants.js\":{\"offset\":138219,\"length\":167,\"mode\":420},\"/node_modules/bare-tcp/lib/errors.js\":{\"offset\":138386,\"length\":841,\"mode\":420},\"/node_modules/bare-tcp/lib/ip.js\":{\"offset\":139227,\"length\":2204,\"mode\":420},\"/node_modules/bare-tcp/package.json\":{\"offset\":141431,\"length\":1126,\"mode\":420},\"/node_modules/bare-tls/binding.js\":{\"offset\":142557,\"length\":33,\"mode\":420},\"/node_modules/bare-tls/index.js\":{\"offset\":142590,\"length\":4031,\"mode\":420},\"/node_modules/bare-tls/lib/constants.js\":{\"offset\":146621,\"length\":55,\"mode\":420},\"/node_modules/bare-tls/lib/errors.js\":{\"offset\":146676,\"length\":358,\"mode\":420},\"/node_modules/bare-tls/package.json\":{\"offset\":147034,\"length\":1071,\"mode\":420},\"/node_modules/bare-url/binding.js\":{\"offset\":148105,\"length\":33,\"mode\":420},\"/node_modules/bare-url/index.js\":{\"offset\":148138,\"length\":7957,\"mode\":420},\"/node_modules/bare-url/lib/errors.js\":{\"offset\":156095,\"length\":881,\"mode\":420},\"/node_modules/bare-url/package.json\":{\"offset\":156976,\"length\":1104,\"mode\":420},\"/node_modules/bare-ws/index.js\":{\"offset\":158080,\"length\":82,\"mode\":420},\"/node_modules/bare-ws/lib/constants.js\":{\"offset\":158162,\"length\":439,\"mode\":420},\"/node_modules/bare-ws/lib/errors.js\":{\"offset\":158601,\"length\":3930,\"mode\":420},\"/node_modules/bare-ws/lib/frame.js\":{\"offset\":162531,\"length\":3581,\"mode\":420},\"/node_modules/bare-ws/lib/server.js\":{\"offset\":166112,\"length\":2771,\"mode\":420},\"/node_modules/bare-ws/lib/socket.js\":{\"offset\":168883,\"length\":7007,\"mode\":420},\"/node_modules/bare-ws/package.json\":{\"offset\":175890,\"length\":970,\"mode\":420},\"/node_modules/crypto/index.js\":{\"offset\":176860,\"length\":40,\"mode\":420},\"/node_modules/crypto/package.json\":{\"offset\":176900,\"length\":564,\"mode\":420},\"/node_modules/events/index.js\":{\"offset\":177464,\"length\":40,\"mode\":420},\"/node_modules/events/package.json\":{\"offset\":177504,\"length\":564,\"mode\":420},\"/node_modules/fast-fifo/fixed-size.js\":{\"offset\":178068,\"length\":875,\"mode\":420},\"/node_modules/fast-fifo/index.js\":{\"offset\":178943,\"length\":972,\"mode\":420},\"/node_modules/fast-fifo/package.json\":{\"offset\":179915,\"length\":682,\"mode\":420},\"/node_modules/streamx/index.js\":{\"offset\":180597,\"length\":33174,\"mode\":420},\"/node_modules/streamx/package.json\":{\"offset\":213771,\"length\":912,\"mode\":420},\"/node_modules/text-decoder/index.js\":{\"offset\":214683,\"length\":1378,\"mode\":420},\"/node_modules/text-decoder/lib/pass-through-decoder.js\":{\"offset\":216061,\"length\":273,\"mode\":420},\"/node_modules/text-decoder/lib/utf8-decoder.js\":{\"offset\":216334,\"length\":2529,\"mode\":420},\"/node_modules/text-decoder/package.json\":{\"offset\":218863,\"length\":987,\"mode\":420},\"/node_modules/url/index.js\":{\"offset\":219850,\"length\":37,\"mode\":420},\"/node_modules/url/package.json\":{\"offset\":219887,\"length\":555,\"mode\":420},\"/node_modules/uuid/dist/cjs/index.js\":{\"offset\":220442,\"length\":2382,\"mode\":420},\"/node_modules/uuid/dist/cjs/max.js\":{\"offset\":222824,\"length\":135,\"mode\":420},\"/node_modules/uuid/dist/cjs/md5.js\":{\"offset\":222959,\"length\":393,\"mode\":420},\"/node_modules/uuid/dist/cjs/native.js\":{\"offset\":223352,\"length\":168,\"mode\":420},\"/node_modules/uuid/dist/cjs/nil.js\":{\"offset\":223520,\"length\":135,\"mode\":420},\"/node_modules/uuid/dist/cjs/package.json\":{\"offset\":223655,\"length\":20,\"mode\":420},\"/node_modules/uuid/dist/cjs/parse.js\":{\"offset\":223675,\"length\":720,\"mode\":420},\"/node_modules/uuid/dist/cjs/regex.js\":{\"offset\":224395,\"length\":251,\"mode\":420},\"/node_modules/uuid/dist/cjs/rng.js\":{\"offset\":224646,\"length\":399,\"mode\":420},\"/node_modules/uuid/dist/cjs/sha1.js\":{\"offset\":225045,\"length\":396,\"mode\":420},\"/node_modules/uuid/dist/cjs/stringify.js\":{\"offset\":225441,\"length\":1271,\"mode\":420},\"/node_modules/uuid/dist/cjs/v1.js\":{\"offset\":226712,\"length\":2893,\"mode\":420},\"/node_modules/uuid/dist/cjs/v1ToV6.js\":{\"offset\":229605,\"length\":978,\"mode\":420},\"/node_modules/uuid/dist/cjs/v3.js\":{\"offset\":230583,\"length\":637,\"mode\":420},\"/node_modules/uuid/dist/cjs/v35.js\":{\"offset\":231220,\"length\":1578,\"mode\":420},\"/node_modules/uuid/dist/cjs/v4.js\":{\"offset\":232798,\"length\":1047,\"mode\":420},\"/node_modules/uuid/dist/cjs/v5.js\":{\"offset\":233845,\"length\":640,\"mode\":420},\"/node_modules/uuid/dist/cjs/v6.js\":{\"offset\":234485,\"length\":620,\"mode\":420},\"/node_modules/uuid/dist/cjs/v6ToV1.js\":{\"offset\":235105,\"length\":978,\"mode\":420},\"/node_modules/uuid/dist/cjs/v7.js\":{\"offset\":236083,\"length\":2339,\"mode\":420},\"/node_modules/uuid/dist/cjs/validate.js\":{\"offset\":238422,\"length\":245,\"mode\":420},\"/node_modules/uuid/dist/cjs/version.js\":{\"offset\":238667,\"length\":316,\"mode\":420},\"/package.json\":{\"offset\":238983,\"length\":1411,\"mode\":420},\"/proxy/ProxyClient.js\":{\"offset\":240394,\"length\":3058,\"mode\":420},\"/proxy/ProxyServer.js\":{\"offset\":243452,\"length\":3412,\"mode\":420},\"/proxy/index.js\":{\"offset\":246864,\"length\":704,\"mode\":420},\"/transport/BaseTransport.js\":{\"offset\":247568,\"length\":1305,\"mode\":420},\"/transport/DesktopIPCTransport.js\":{\"offset\":248873,\"length\":3957,\"mode\":420},\"/transport/HTTPTransport.js\":{\"offset\":252830,\"length\":6156,\"mode\":420},\"/transport/MobileIPCTransport.js\":{\"offset\":258986,\"length\":2432,\"mode\":420},\"/transport/WebSocketTransport.js\":{\"offset\":261418,\"length\":3155,\"mode\":420},\"/transport/index.js\":{\"offset\":264573,\"length\":879,\"mode\":420}}}\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst { MobileIPCTransport } = require('../../transport')\nconst { ProxyServer } = require('../../proxy')\nconst EventEmitter = require('events')\nconst { IPC } = BareKit\n\nclass MathHandler {\n  async add (a, b) {\n    return a + b\n  }\n\n  async multiply (a, b) {\n    return a * b\n  }\n}\n\nclass Handler extends EventEmitter {\n  constructor () {\n    super()\n    this.math = new MathHandler()\n  }\n\n  async hello (name) {\n    console.log('Hello called')\n    return `Hello ${name}`\n  }\n\n  async emitTestEvent (data) {\n    this.emit('onceEvent', data)\n    return 'onceEvent emitted'\n  }\n\n  async chainExample (value) {\n    return value\n  }\n}\n\nconst handler = new Handler()\nconst transport = new MobileIPCTransport({ IPC, isServer: true })\nconst server = new ProxyServer(transport)\nserver.exposeHandler(handler)\n\ntransport.start()\n\nsetInterval(() => {\n  console.log('before heartbeat')\n  handler.emit('heartbeat', Date.now())\n  console.log('after heartbeat')\n}, 1000)\n\nconsole.log('Mobile IPC Child started')\nfunction isBuffer (value) {\n  return Buffer.isBuffer(value) || value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  return Buffer.isEncoding(encoding)\n}\n\nfunction alloc (size, fill, encoding) {\n  return Buffer.alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  return Buffer.allocUnsafe(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return Buffer.allocUnsafeSlow(size)\n}\n\nfunction byteLength (string, encoding) {\n  return Buffer.byteLength(string, encoding)\n}\n\nfunction compare (a, b) {\n  return Buffer.compare(a, b)\n}\n\nfunction concat (buffers, totalLength) {\n  return Buffer.concat(buffers, totalLength)\n}\n\nfunction copy (source, target, targetStart, start, end) {\n  return toBuffer(source).copy(target, targetStart, start, end)\n}\n\nfunction equals (a, b) {\n  return toBuffer(a).equals(b)\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  return toBuffer(buffer).fill(value, offset, end, encoding)\n}\n\nfunction from (value, encodingOrOffset, length) {\n  return Buffer.from(value, encodingOrOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).includes(value, byteOffset, encoding)\n}\n\nfunction indexOf (buffer, value, byfeOffset, encoding) {\n  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)\n}\n\nfunction swap16 (buffer) {\n  return toBuffer(buffer).swap16()\n}\n\nfunction swap32 (buffer) {\n  return toBuffer(buffer).swap32()\n}\n\nfunction swap64 (buffer) {\n  return toBuffer(buffer).swap64()\n}\n\nfunction toBuffer (buffer) {\n  if (Buffer.isBuffer(buffer)) return buffer\n  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\nfunction toString (buffer, encoding, start, end) {\n  return toBuffer(buffer).toString(encoding, start, end)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  return toBuffer(buffer).write(string, offset, length, encoding)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleLE(value, offset)\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatLE(value, offset)\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32LE(value, offset)\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32LE(value, offset)\n}\n\nfunction readDoubleLE (buffer, offset) {\n  return toBuffer(buffer).readDoubleLE(offset)\n}\n\nfunction readFloatLE (buffer, offset) {\n  return toBuffer(buffer).readFloatLE(offset)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  return toBuffer(buffer).readUInt32LE(offset)\n}\n\nfunction readInt32LE (buffer, offset) {\n  return toBuffer(buffer).readInt32LE(offset)\n}\n\nfunction writeDoubleBE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleBE(value, offset)\n}\n\nfunction writeFloatBE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatBE(value, offset)\n}\n\nfunction writeUInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32BE(value, offset)\n}\n\nfunction writeInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32BE(value, offset)\n}\n\nfunction readDoubleBE (buffer, offset) {\n  return toBuffer(buffer).readDoubleBE(offset)\n}\n\nfunction readFloatBE (buffer, offset) {\n  return toBuffer(buffer).readFloatBE(offset)\n}\n\nfunction readUInt32BE (buffer, offset) {\n  return toBuffer(buffer).readUInt32BE(offset)\n}\n\nfunction readInt32BE (buffer, offset) {\n  return toBuffer(buffer).readInt32BE(offset)\n}\n\nmodule.exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE,\n  writeDoubleBE,\n  writeFloatBE,\n  writeUInt32BE,\n  writeInt32BE,\n  readDoubleBE,\n  readFloatBE,\n  readUInt32BE,\n  readInt32BE\n\n}\n{\n  \"name\": \"b4a\",\n  \"version\": \"1.6.7\",\n  \"description\": \"Bridging the gap between buffers and typed arrays\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"browser.js\",\n    \"index.js\",\n    \"lib\"\n  ],\n  \"browser\": {\n    \"./index.js\": \"./browser.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/b4a.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/b4a/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/b4a#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"nanobench\": \"^3.0.0\",\n    \"standard\": \"^17.1.0\"\n  }\n}\nmodule.exports = require.addon()\nconst { Transform } = require('bare-stream')\nconst binding = require('./binding')\nconst constants = (exports.constants = require('./lib/constants'))\nconst errors = (exports.errors = require('./lib/errors'))\n\nexports.Hash = class CryptoHash extends Transform {\n  constructor(algorithm, opts = {}) {\n    super(opts)\n\n    if (typeof algorithm === 'string') {\n      if (algorithm in constants.hash) algorithm = constants.hash[algorithm]\n      else {\n        algorithm = algorithm.toUpperCase()\n\n        if (algorithm in constants.hash) algorithm = constants.hash[algorithm]\n        else {\n          throw errors.UNSUPPORTED_DIGEST_METHOD(\n            `Unsupported digest method '${algorithm}'`\n          )\n        }\n      }\n    }\n\n    this._handle = binding.hashInit(algorithm)\n  }\n\n  update(data, encoding = 'utf8') {\n    if (typeof data === 'string') data = Buffer.from(data, encoding)\n\n    binding.hashUpdate(this._handle, data)\n\n    return this\n  }\n\n  digest(encoding) {\n    const digest = Buffer.from(binding.hashFinal(this._handle))\n\n    return encoding ? digest.toString(encoding) : digest\n  }\n\n  _transform(data, encoding, cb) {\n    this.update(data)\n\n    cb(null)\n  }\n\n  _flush(cb) {\n    this.push(this.digest())\n\n    cb(null)\n  }\n}\n\nexports.createHash = function createHash(algorithm, opts) {\n  return new exports.Hash(algorithm, opts)\n}\n\nexports.randomBytes = function randomBytes(size, cb) {\n  const buffer = Buffer.allocUnsafe(size)\n  exports.randomFill(buffer)\n  if (cb) queueMicrotask(() => cb(null, buffer))\n  else return buffer\n}\n\nexports.randomFill = function randomFill(buffer, offset, size, cb) {\n  if (typeof offset === 'function') {\n    cb = offset\n    offset = undefined\n  } else if (typeof size === 'function') {\n    cb = size\n    size = undefined\n  }\n\n  const elementSize = buffer.BYTES_PER_ELEMENT || 1\n\n  if (offset === undefined) offset = 0\n  else offset *= elementSize\n\n  if (size === undefined) size = buffer.byteLength - offset\n  else size *= elementSize\n\n  if (offset < 0 || offset > buffer.byteLength) {\n    throw new RangeError('offset is out of range')\n  }\n\n  if (size < 0 || size > buffer.byteLength) {\n    throw new RangeError('size is out of range')\n  }\n\n  if (offset + size > buffer.byteLength) {\n    throw new RangeError('offset + size is out of range')\n  }\n\n  let arraybuffer\n\n  if (ArrayBuffer.isView(buffer)) {\n    offset += buffer.byteOffset\n    arraybuffer = buffer.buffer\n  } else {\n    arraybuffer = buffer\n  }\n\n  binding.randomFill(arraybuffer, offset, size)\n\n  if (cb) queueMicrotask(() => cb(null, buffer))\n  else return buffer\n}\n\n// For Node.js compatibility\nexports.randomFillSync = function randomFillSync(buffer, offset, size) {\n  return exports.randomFill(buffer, offset, size)\n}\n\n// For Node.js compatibility\nexports.webcrypto = require('./web')\nconst binding = require('../binding')\n\nmodule.exports = {\n  hash: {\n    MD5: binding.MD5,\n    SHA1: binding.SHA1,\n    SHA256: binding.SHA256,\n    SHA512: binding.SHA512,\n    BLAKE2B256: binding.BLAKE2B256\n  }\n}\nmodule.exports = class CryptoError extends Error {\n  constructor(msg, code, fn = CryptoError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'CryptoError'\n  }\n\n  static UNSUPPORTED_DIGEST_METHOD(msg) {\n    return new CryptoError(\n      msg,\n      'UNSUPPORTED_DIGEST_METHOD',\n      CryptoError.UNSUPPORTED_DIGEST_METHOD\n    )\n  }\n}\n{\n  \"name\": \"bare-crypto\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Cryptographic primitives for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./web\": {\n      \"types\": \"./web.d.ts\",\n      \"default\": \"./web.js\"\n    },\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"web.js\",\n    \"web.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-crypto.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-crypto/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-crypto#readme\",\n  \"dependencies\": {\n    \"bare-stream\": \"^2.6.3\"\n  },\n  \"devDependencies\": {\n    \"bare-buffer\": \"^3.0.1\",\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  },\n  \"peerDependencies\": {\n    \"bare-buffer\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bare-buffer\": {\n      \"optional\": true\n    }\n  }\n}\nconst crypto = require('.')\n\n// https://w3c.github.io/webcrypto/#Crypto-method-getRandomValues\nexports.getRandomValues = function getRandomValues(array) {\n  return crypto.randomFillSync(array)\n}\nmodule.exports = require.addon()\nconst binding = require('./binding')\n\nfunction onlookup(err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null, 0)\n\n  const { address, family } = addresses[0]\n\n  return req.cb(null, address, family)\n}\n\nfunction onlookupall(err, addresses) {\n  const req = this\n\n  if (err) return req.cb(err, null)\n\n  return req.cb(null, addresses)\n}\n\nexports.lookup = function lookup(hostname, opts = {}, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  let { family = 0, all = false } = opts\n\n  if (typeof family === 'string') {\n    switch (family) {\n      case 'IPv4':\n        family = 4\n        break\n      case 'IPv6':\n        family = 6\n        break\n      default:\n        family = 0\n    }\n  }\n\n  const req = {\n    cb,\n    handle: null\n  }\n\n  req.handle = binding.lookup(\n    hostname,\n    family || 0,\n    all,\n    req,\n    all ? onlookupall : onlookup\n  )\n}\n{\n  \"name\": \"bare-dns\",\n  \"version\": \"2.0.4\",\n  \"description\": \"Domain name resolution for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-dns.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-dns/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-dns\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nconst errors = require('./lib/errors')\n\nclass EventListener {\n  constructor() {\n    this.list = []\n    this.count = 0\n  }\n\n  append(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.push([fn, once])\n  }\n\n  prepend(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.unshift([fn, once])\n  }\n\n  remove(ctx, name, fn) {\n    for (let i = 0, n = this.list.length; i < n; i++) {\n      const l = this.list[i]\n\n      if (l[0] === fn) {\n        this.list.splice(i, 1)\n\n        if (this.count === 1) delete ctx._events[name]\n\n        ctx.emit('removeListener', name, fn) // Emit AFTER removing\n\n        this.count--\n        return\n      }\n    }\n  }\n\n  removeAll(ctx, name) {\n    const list = [...this.list]\n    this.list = []\n\n    if (this.count === list.length) delete ctx._events[name]\n\n    for (let i = list.length - 1; i >= 0; i--) {\n      ctx.emit('removeListener', name, list[i][0]) // Emit AFTER removing\n    }\n\n    this.count -= list.length\n  }\n\n  emit(ctx, name, ...args) {\n    const list = [...this.list]\n\n    for (let i = 0, n = list.length; i < n; i++) {\n      const l = list[i]\n\n      if (l[1] === true) this.remove(ctx, name, l[0])\n\n      l[0].call(ctx, ...args)\n    }\n\n    return list.length > 0\n  }\n}\n\nfunction appendListener(ctx, name, fn, once) {\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.append(ctx, name, fn, once)\n  return ctx\n}\n\nfunction prependListener(ctx, name, fn, once) {\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.prepend(ctx, name, fn, once)\n  return ctx\n}\n\nfunction removeListener(ctx, name, fn) {\n  const e = ctx._events[name]\n  if (e !== undefined) e.remove(ctx, name, fn)\n  return ctx\n}\n\nfunction throwUnhandledError(...args) {\n  let err\n\n  if (args.length > 0) err = args[0]\n\n  if (err instanceof Error === false) err = errors.UNHANDLED_ERROR(err)\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(err, exports.prototype.emit)\n  }\n\n  queueMicrotask(() => {\n    throw err\n  })\n}\n\nmodule.exports = exports = class EventEmitter {\n  constructor() {\n    this._events = Object.create(null)\n  }\n\n  addListener(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  addOnceListener(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  prependListener(name, fn) {\n    return prependListener(this, name, fn, false)\n  }\n\n  prependOnceListener(name, fn) {\n    return prependListener(this, name, fn, true)\n  }\n\n  removeListener(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  on(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  once(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  off(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  emit(name, ...args) {\n    if (name === 'error' && this._events.error === undefined) {\n      throwUnhandledError(...args)\n    }\n\n    const e = this._events[name]\n    return e === undefined ? false : e.emit(this, name, ...args)\n  }\n\n  listeners(name) {\n    const e = this._events[name]\n    return e === undefined ? [] : [...e.list]\n  }\n\n  listenerCount(name) {\n    const e = this._events[name]\n    return e === undefined ? 0 : e.list.length\n  }\n\n  getMaxListeners() {\n    return EventEmitter.defaultMaxListeners\n  }\n\n  setMaxListeners(n) {}\n\n  removeAllListeners(name) {\n    if (arguments.length === 0) {\n      for (const key of Reflect.ownKeys(this._events)) {\n        if (key === 'removeListener') continue\n        this.removeAllListeners(key)\n      }\n      this.removeAllListeners('removeListener')\n    } else {\n      const e = this._events[name]\n      if (e !== undefined) e.removeAll(this, name)\n    }\n    return this\n  }\n}\n\nexports.EventEmitter = exports\n\nexports.errors = errors\n\nexports.defaultMaxListeners = 10\n\nexports.on = function on(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    throw errors.OPERATION_ABORTED(signal.reason)\n  }\n\n  let error = null\n  let done = false\n\n  const events = []\n  const promises = []\n\n  emitter.on(name, onevent)\n\n  if (name !== 'error') emitter.on('error', onerror)\n\n  if (signal) signal.addEventListener('abort', onabort)\n\n  return {\n    next() {\n      if (events.length) {\n        return Promise.resolve({ value: events.shift(), done: false })\n      }\n\n      if (error) {\n        const err = error\n\n        error = null\n\n        return Promise.reject(err)\n      }\n\n      if (done) return onclose()\n\n      return new Promise((resolve, reject) =>\n        promises.push({ resolve, reject })\n      )\n    },\n\n    return() {\n      return onclose()\n    },\n\n    throw(err) {\n      return onerror(err)\n    },\n\n    [Symbol.asyncIterator]() {\n      return this\n    }\n  }\n\n  function onevent(...args) {\n    if (promises.length) {\n      promises.shift().resolve({ value: args, done: false })\n    } else {\n      events.push(args)\n    }\n  }\n\n  function onerror(err) {\n    if (promises.length) {\n      promises.shift().reject(err)\n    } else {\n      error = err\n    }\n\n    return Promise.resolve({ done: true })\n  }\n\n  function onabort() {\n    onerror(errors.OPERATION_ABORTED(signal.reason))\n  }\n\n  function onclose() {\n    emitter.off(name, onevent)\n\n    if (name !== 'error') emitter.off('error', onerror)\n\n    if (signal) signal.removeEventListener('abort', onabort)\n\n    done = true\n\n    if (promises.length) promises.shift().resolve({ done: true })\n\n    return Promise.resolve({ done: true })\n  }\n}\n\nexports.once = function once(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    throw errors.OPERATION_ABORTED(signal.reason)\n  }\n\n  return new Promise((resolve, reject) => {\n    if (name !== 'error') emitter.on('error', onerror)\n\n    if (signal) signal.addEventListener('abort', onabort)\n\n    emitter.once(name, (...args) => {\n      if (name !== 'error') emitter.off('error', onerror)\n\n      if (signal) signal.removeEventListener('abort', onabort)\n\n      resolve(args)\n    })\n\n    function onerror(err) {\n      emitter.off('error', onerror)\n\n      reject(err)\n    }\n\n    function onabort() {\n      signal.removeEventListener('abort', onabort)\n\n      onerror(errors.OPERATION_ABORTED(signal.reason))\n    }\n  })\n}\n\nexports.forward = function forward(from, to, names, opts = {}) {\n  if (typeof names === 'string') names = [names]\n\n  const { emit = to.emit.bind(to) } = opts\n\n  const listeners = names.map(\n    (name) =>\n      function onevent(...args) {\n        emit(name, ...args)\n      }\n  )\n\n  to.on('newListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.on(name, listeners[i])\n    }\n  }).on('removeListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.off(name, listeners[i])\n    }\n  })\n}\n\nexports.listenerCount = function listenerCount(emitter, name) {\n  return emitter.listenerCount(name)\n}\nmodule.exports = class EventEmitterError extends Error {\n  constructor(msg, code, fn = EventEmitterError, opts) {\n    super(`${code}: ${msg}`, opts)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'EventEmitterError'\n  }\n\n  static OPERATION_ABORTED(cause, msg = 'Operation aborted') {\n    return new EventEmitterError(\n      msg,\n      'OPERATION_ABORTED',\n      EventEmitterError.OPERATION_ABORTED,\n      { cause }\n    )\n  }\n\n  static UNHANDLED_ERROR(cause, msg = 'Unhandled error') {\n    return new EventEmitterError(\n      msg,\n      'UNHANDLED_ERROR',\n      EventEmitterError.UNHANDLED_ERROR,\n      { cause }\n    )\n  }\n}\n{\n  \"name\": \"bare-events\",\n  \"version\": \"2.5.4\",\n  \"description\": \"Event emitters for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.js\",\n    \"test:node\": \"node test.js\",\n    \"lint\": \"prettier . --check\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-events.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-events/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-events#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nconst http = require('bare-http1')\nconst https = require('bare-https')\nconst { ReadableStream } = require('bare-stream/web')\nconst Request = require('./lib/request')\nconst Response = require('./lib/response')\nconst Headers = require('./lib/headers')\nconst errors = require('./lib/errors')\n\n// https://fetch.spec.whatwg.org/#dom-global-fetch\nmodule.exports = exports = function fetch(input, init = {}) {\n  let resolve\n  let reject\n\n  const promise = new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  const response = new Response()\n\n  process(input)\n\n  return promise\n\n  async function process(input) {\n    let request\n    try {\n      request = new Request(input, init)\n    } catch (err) {\n      return reject(err)\n    }\n\n    if (response._urls.length > 20) {\n      return reject(errors.TOO_MANY_REDIRECTS('Redirect count exceeded'))\n    }\n\n    let protocol\n\n    if (request._url.protocol === 'http:') {\n      protocol = http\n    } else if (request._url.protocol === 'https:') {\n      protocol = https\n    } else {\n      return reject(errors.UNKNOWN_PROTOCOL('Unknown protocol'))\n    }\n\n    response._urls.push(request._url)\n\n    if (!request._headers.has('user-agent')) {\n      request._headers.set('user-agent', `Bare/${Bare.version.substring(1)}`)\n    }\n\n    const req = protocol.request(\n      request._url,\n      {\n        method: request._method,\n        headers: Object.fromEntries(request._headers)\n      },\n      (res) => {\n        if (res.headers.location && isRedirectStatus(res.statusCode)) {\n          return process(res.headers.location)\n        }\n\n        response._body = new ReadableStream(res)\n        response._status = res.statusCode\n        response._statusText = res.statusMessage\n\n        for (const [name, value] of Object.entries(res.headers)) {\n          response._headers.set(name, value)\n        }\n\n        resolve(response)\n      }\n    )\n\n    req.on('error', (err) => reject(errors.NETWORK_ERROR('Network error', err)))\n\n    try {\n      if (request._body) {\n        for await (const data of request._body) req.write(data)\n      }\n\n      req.end()\n    } catch (err) {\n      return reject(errors.NETWORK_ERROR('Network error', err))\n    }\n  }\n}\n\nexports.Request = Request\nexports.Response = Response\nexports.Headers = Headers\n\n// https://fetch.spec.whatwg.org/#redirect-status\nfunction isRedirectStatus(status) {\n  return (\n    status === 301 ||\n    status === 302 ||\n    status === 303 ||\n    status === 307 ||\n    status === 308\n  )\n}\nconst { ReadableStream, isReadableStreamDisturbed } = require('bare-stream/web')\nconst errors = require('./errors')\n\nconst empty = Buffer.from(new ArrayBuffer(0))\n\n// https://fetch.spec.whatwg.org/#body-mixin\nmodule.exports = class Body {\n  constructor(body = null) {\n    this._body = null\n\n    if (typeof body === 'string') body = Buffer.from(body)\n\n    if (Buffer.isBuffer(body)) {\n      this._body = new ReadableStream({\n        start(controller) {\n          controller.enqueue(body)\n          controller.close()\n        }\n      })\n    } else if (body !== null) {\n      this._body = body\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body() {\n    return this._body\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed() {\n    return this._body !== null && isReadableStreamDisturbed(this._body)\n  }\n\n  async buffer() {\n    if (this._body === null) return empty\n\n    if (isReadableStreamDisturbed(this._body)) {\n      throw errors.BODY_UNUSABLE('Body has already been consumed')\n    }\n\n    const chunks = []\n    let length = 0\n\n    for await (const chunk of this._body) {\n      chunks.push(chunk)\n      length += chunk.byteLength\n    }\n\n    const result = Buffer.from(new ArrayBuffer(length))\n    let offset = 0\n\n    for (const chunk of chunks) {\n      result.set(chunk, offset)\n      offset += chunk.byteLength\n    }\n\n    return result\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bytes\n  async bytes() {\n    return this.buffer()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer() {\n    return (await this.buffer()).buffer\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text() {\n    return (await this.buffer()).toString('utf8')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json() {\n    return JSON.parse(await this.text())\n  }\n}\nmodule.exports = class FetchError extends Error {\n  constructor(msg, code, fn = FetchError, cause) {\n    super(`${code}: ${msg}`, { cause })\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'FetchError'\n  }\n\n  static INVALID_URL(msg, cause) {\n    return new FetchError(msg, 'INVALID_URL', FetchError.INVALID_URL, cause)\n  }\n\n  static NETWORK_ERROR(msg, cause) {\n    return new FetchError(msg, 'NETWORK_ERROR', FetchError.NETWORK_ERROR, cause)\n  }\n\n  static TOO_MANY_REDIRECTS(msg) {\n    return new FetchError(\n      msg,\n      'TOO_MANY_REDIRECTS',\n      FetchError.TOO_MANY_REDIRECTS\n    )\n  }\n\n  static UNKNOWN_PROTOCOL(msg) {\n    return new FetchError(msg, 'UNKNOWN_PROTOCOL', FetchError.UNKNOWN_PROTOCOL)\n  }\n\n  static BODY_UNUSABLE(msg) {\n    return new FetchError(msg, 'BODY_UNUSABLE', FetchError.BODY_UNUSABLE)\n  }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nmodule.exports = class Headers {\n  // https://fetch.spec.whatwg.org/#dom-headers\n  constructor(init) {\n    this._headers = new Map()\n\n    if (init) {\n      for (const [key, value] of typeof init[Symbol.iterator] === 'function'\n        ? init\n        : Object.entries(init)) {\n        this.append(key, value)\n      }\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append(name, value) {\n    name = name.toLowerCase()\n    value = value.trim()\n\n    let list = this._headers.get(name)\n\n    if (list === undefined) {\n      list = []\n      this._headers.set(name, list)\n    }\n\n    list.push(value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete(name) {\n    name = name.toLowerCase()\n\n    this._headers.delete(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get(name) {\n    name = name.toLowerCase()\n\n    const list = this._headers.get(name)\n\n    if (list === undefined) return null\n\n    return list.join(', ')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has(name) {\n    name = name.toLowerCase()\n\n    return this._headers.has(name)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set(name, value) {\n    name = name.toLowerCase()\n    value = value.trim()\n\n    this._headers.set(name, [value])\n  }\n\n  *[Symbol.iterator]() {\n    const names = [...this._headers.keys()].sort()\n\n    for (const name of names) {\n      yield [name, this.get(name)]\n    }\n  }\n}\nconst Body = require('./body')\nconst Headers = require('./headers')\nconst errors = require('./errors')\n\n// https://fetch.spec.whatwg.org/#request-class\nmodule.exports = class Request extends Body {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor(input, init = {}) {\n    const { body = null, method = 'GET', headers } = init\n\n    super(body)\n\n    let url\n    try {\n      url = new URL(input)\n    } catch (err) {\n      throw errors.INVALID_URL('Invalid URL', err)\n    }\n\n    this._url = url\n    this._method = method\n    this._headers = new Headers(headers)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-request-url\n  get url() {\n    return this._url.href\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-request-method\n  get method() {\n    return this._method\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-headers\n  get headers() {\n    return this._headers\n  }\n}\nconst Body = require('./body')\nconst Headers = require('./headers')\n\n// https://fetch.spec.whatwg.org/#response-class\nmodule.exports = class Response extends Body {\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor(body = null, init = {}) {\n    const { status = 200, statusText = '', headers } = init\n\n    super(body)\n\n    this._urls = []\n    this._status = status\n    this._statusText = statusText\n    this._headers = new Headers(headers)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-url\n  get url() {\n    return this._urls.length === 0\n      ? null\n      : this._urls[this._urls.length - 1].href\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-redirected\n  get redirected() {\n    return this._urls.length > 1\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-status\n  get status() {\n    return this._status\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-ok\n  get ok() {\n    return this._status >= 200 && this._status <= 299\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-statustext\n  get statusText() {\n    return this._statusText\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-headers\n  get headers() {\n    return this._headers\n  }\n}\n{\n  \"name\": \"bare-fetch\",\n  \"version\": \"2.2.0\",\n  \"description\": \"WHATWG Fetch implementation for Bare\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./global\": \"./global.js\",\n    \"./errors\": \"./lib/errors.js\",\n    \"./body\": \"./lib/body.js\",\n    \"./request\": \"./lib/request.js\",\n    \"./response\": \"./lib/response.js\",\n    \"./headers\": \"./lib/headers.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"global.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-fetch.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-fetch/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-fetch#readme\",\n  \"dependencies\": {\n    \"bare-http1\": \"^4.0.2\",\n    \"bare-https\": \"^2.0.0\",\n    \"bare-stream\": \"^2.6.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"listen-async\": \"^1.0.0\",\n    \"prettier\": \"^3.3.3\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nexports.IncomingMessage = require('./lib/incoming-message')\nexports.OutgoingMessage = require('./lib/outgoing-message')\n\nexports.Agent = require('./lib/agent')\nexports.globalAgent = exports.Agent.global\n\nexports.Server = require('./lib/server')\nexports.ServerResponse = require('./lib/server-response')\nexports.ServerConnection = require('./lib/server-connection')\n\nexports.ClientRequest = require('./lib/client-request')\nexports.ClientConnection = require('./lib/client-connection')\n\nexports.constants = require('./lib/constants')\n\nexports.STATUS_CODES = exports.constants.status // For Node.js compatibility\n\nexports.createServer = function createServer(opts, onrequest) {\n  return new exports.Server(opts, onrequest)\n}\n\nexports.request = function request(url, opts, onresponse) {\n  if (typeof opts === 'function') {\n    onresponse = opts\n    opts = {}\n  }\n\n  if (typeof url === 'string') url = new URL(url)\n\n  if (isURL(url)) {\n    opts = opts ? { ...opts } : {}\n\n    opts.host = url.hostname\n    opts.path = url.pathname + url.search\n    opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n  } else {\n    opts = url ? { ...url } : {}\n\n    // For Node.js compatibility\n    opts.host = opts.hostname || opts.host\n    opts.port =\n      typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n  }\n\n  return new exports.ClientRequest(opts, onresponse)\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort(url) {\n  switch (url.protocol) {\n    case 'ftp:':\n      return 21\n    case 'http:':\n    case 'ws:':\n      return 80\n    case 'https:':\n    case 'wss:':\n      return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL(url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\nconst tcp = require('bare-tcp')\nconst HTTPClientConnection = require('./client-connection')\n\nmodule.exports = class HTTPAgent {\n  constructor(opts = {}) {\n    const { keepAlive = false, keepAliveMsecs = 1000 } = opts\n\n    this._sockets = new Map()\n    this._freeSockets = new Map()\n\n    this._keepAlive =\n      typeof keepAlive === 'number'\n        ? keepAlive\n        : keepAlive\n          ? keepAliveMsecs\n          : -1\n\n    this._opts = { ...opts }\n  }\n\n  createConnection(opts) {\n    return tcp.createConnection(opts)\n  }\n\n  reuseSocket(socket, req) {\n    socket.ref()\n  }\n\n  keepSocketAlive(socket) {\n    if (this._keepAlive === -1) return false\n\n    socket.setKeepAlive(true, this._keepAlive)\n    socket.unref()\n\n    return true\n  }\n\n  getName(opts) {\n    return `${opts.host}:${opts.port}`\n  }\n\n  addRequest(req, opts) {\n    opts = { ...opts, ...this._opts }\n\n    const name = this.getName(opts)\n\n    let socket\n\n    if (this._freeSockets.has(name)) {\n      const sockets = this._freeSockets.get(name)\n      socket = sockets.values().next().value\n      sockets.delete(socket)\n      if (sockets.size === 0) this._freeSockets.delete(name)\n\n      this.reuseSocket(socket, req)\n    } else {\n      socket = this.createConnection(opts)\n\n      socket\n        .on('free', () => this._onfree(socket, name))\n        .on('close', () => this._onremove(socket, name))\n        .on('timeout', () => this._ontimeout(socket, name))\n    }\n\n    let sockets = this._sockets.get(name)\n    if (sockets === undefined) {\n      sockets = new Set()\n      this._sockets.set(name, sockets)\n    }\n\n    sockets.add(socket)\n\n    req.socket = socket\n\n    const connection = HTTPClientConnection.from(socket, opts)\n\n    connection.req = req\n  }\n\n  destroy() {\n    for (const set of [this._sockets, this._freeSockets]) {\n      for (const [, sockets] of set) {\n        for (const socket of sockets) socket.destroy()\n      }\n    }\n  }\n\n  _onfree(socket, name) {\n    if (this.keepSocketAlive(socket)) {\n      this._onremove(socket, name, false)\n\n      let sockets = this._freeSockets.get(name)\n      if (sockets === undefined) {\n        sockets = new Set()\n        this._freeSockets.set(name, sockets)\n      }\n\n      sockets.add(socket)\n    } else {\n      socket.end()\n    }\n  }\n\n  _onremove(socket, name, all = true) {\n    for (const set of all\n      ? [this._sockets, this._freeSockets]\n      : [this._sockets]) {\n      const sockets = set.get(name)\n      if (sockets === undefined) continue\n\n      sockets.delete(socket)\n      if (sockets.size === 0) set.delete(name)\n    }\n  }\n\n  _ontimeout(socket, name) {\n    const sockets = this._freeSockets.get(name)\n    if (!sockets) return\n\n    if (sockets.delete(socket)) socket.destroy()\n    if (sockets.size === 0) this._freeSockets.delete(name)\n  }\n\n  static global = new this({ keepAlive: 1000, timeout: 5000 })\n}\nconst HTTPIncomingMessage = require('./incoming-message')\nconst constants = require('./constants')\nconst errors = require('./errors')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPClientConnection {\n  static _connections = new WeakMap()\n\n  static for(socket) {\n    return this._connections.get(socket) || null\n  }\n\n  static from(socket, opts) {\n    return this.for(socket) || new this(socket, opts)\n  }\n\n  constructor(socket, opts = {}) {\n    const { IncomingMessage = HTTPIncomingMessage } = opts\n\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onerror = this._onerror.bind(this)\n    this._onclose = this._onclose.bind(this)\n    this._onend = this._onend.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', this._onerror)\n      .on('close', this._onclose)\n      .on('end', this._onend)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.set(socket, this)\n  }\n\n  get idle() {\n    return this._idle\n  }\n\n  _onerror(err) {\n    if (this.req) this.req.destroy(err)\n  }\n\n  _onclose() {\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onend() {\n    if (this.req) this.req.destroy(errors.CONNECTION_LOST())\n  }\n\n  _ondata(data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead(data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [, statusCode, ...statusMessage] = r[0].split(' ')\n    if (!statusCode || !statusMessage) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req.on('close', () => {\n      this.req = null\n    })\n\n    this.res = new this._IncomingMessage(this.socket, headers, {\n      statusCode: parseInt(statusCode, 10),\n      statusMessage: statusMessage.join(' ')\n    })\n\n    this.res.on('close', () => {\n      this.res = null\n      this._onreset()\n    })\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.req.emit('response', this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength(data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk(data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody(data) {\n    this._read += data.byteLength\n\n    this.res.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade(head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    if (req.emit('upgrade', this.res, this.socket, head || empty)) return\n\n    this.socket.destroy()\n  }\n\n  _ontimeout() {\n    if (this.req) this.req.emit('timeout')\n  }\n\n  _onfinished() {\n    if (this.res) this.res.push(null)\n    if (this.req) this.req._continueFinal()\n  }\n\n  _onreset() {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this.socket.emit('free')\n  }\n\n  _ondrain() {\n    if (this.req) this.req._continueWrite()\n  }\n\n  _ondetach() {\n    this.socket\n      .off('error', this._onerror)\n      .off('close', this._onclose)\n      .off('end', this._onend)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPClientConnection._connections.delete(this.socket)\n  }\n}\nconst HTTPAgent = require('./agent')\nconst HTTPOutgoingMessage = require('./outgoing-message')\n\nmodule.exports = class HTTPClientRequest extends HTTPOutgoingMessage {\n  constructor(opts = {}, onresponse = null) {\n    if (typeof opts === 'function') {\n      onresponse = opts\n      opts = {}\n    }\n\n    opts = opts ? { ...opts } : {}\n\n    const agent =\n      opts.agent === false ? new HTTPAgent() : opts.agent || HTTPAgent.global\n    const method = opts.method || 'GET'\n    const path = opts.path || '/'\n    const host = (opts.host = opts.host || 'localhost')\n    const port = (opts.port = opts.port || 80)\n\n    super()\n\n    agent.addRequest(this, opts)\n\n    this.method = method\n    this.path = path\n    this.headers = { host: host + ':' + port, ...opts.headers }\n\n    this._chunked = method !== 'GET' && method !== 'HEAD'\n\n    this._pendingFinal = null\n\n    if (onresponse) this.once('response', onresponse)\n  }\n\n  _header() {\n    let h = `${this.method} ${this.path} HTTP/1.1\\r\\n`\n\n    let upgrade = false\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'upgrade')\n        upgrade = true\n\n      h += `${httpCase(n)}: ${v}\\r\\n`\n    }\n\n    if (upgrade) this._chunked = false\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write(data, encoding, cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    if (this.headersSent === false) this.flushHeaders()\n\n    if (this._chunked) this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n\n    this._pendingFinal = cb\n  }\n\n  _predestroy() {\n    if (this.upgrade) return this._continueFinal()\n\n    this.socket.destroy()\n  }\n\n  _continueWrite() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n\n  _continueFinal() {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(null)\n  }\n}\n\nfunction httpCase(n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nmodule.exports = {\n  state: {\n    BEFORE_HEAD: 1,\n    IN_HEAD: 2,\n    IN_BODY: 3,\n    BEFORE_CHUNK: 4,\n    IN_CHUNK: 5\n  },\n  method: {\n    GET: 'GET',\n    HEAD: 'HEAD',\n    POST: 'POST',\n    PUT: 'PUT',\n    DELETE: 'DELETE',\n    CONNECT: 'CONNECT',\n    OPTIONS: 'OPTIONS',\n    TRACE: 'TRACE',\n    PATCH: 'PATCH'\n  },\n  status: {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    102: 'Processing',\n    103: 'Early Hints',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    207: 'Multi-Status',\n    208: 'Already Reported',\n    226: 'IM Used',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    308: 'Permanent Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Payload Too Large',\n    414: 'URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Range Not Satisfiable',\n    417: 'Expectation Failed',\n    418: \"I'm a Teapot\",\n    421: 'Misdirected Request',\n    422: 'Unprocessable Entity',\n    423: 'Locked',\n    424: 'Failed Dependency',\n    425: 'Too Early',\n    426: 'Upgrade Required',\n    428: 'Precondition Required',\n    429: 'Too Many Requests',\n    431: 'Request Header Fields Too Large',\n    451: 'Unavailable For Legal Reasons',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported',\n    506: 'Variant Also Negotiates',\n    507: 'Insufficient Storage',\n    508: 'Loop Detected',\n    509: 'Bandwidth Limit Exceeded',\n    510: 'Not Extended',\n    511: 'Network Authentication Required'\n  }\n}\nmodule.exports = class HTTPError extends Error {\n  constructor(msg, code, fn = HTTPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'HTTPError'\n  }\n\n  static NOT_IMPLEMENTED(msg = 'Method not implemented') {\n    return new HTTPError(msg, 'NOT_IMPLEMENTED', HTTPError.NOT_IMPLEMENTED)\n  }\n\n  static CONNECTION_LOST(msg = 'Socket hung up') {\n    return new HTTPError(msg, 'CONNECTION_LOST', HTTPError.CONNECTION_LOST)\n  }\n}\nconst { Readable } = require('bare-stream')\n\nmodule.exports = class HTTPIncomingMessage extends Readable {\n  constructor(socket = null, headers = {}, opts = {}) {\n    super()\n\n    this.socket = socket\n    this.headers = headers\n    this.upgrade = false\n\n    // Server options\n    this.method = opts.method || ''\n    this.url = opts.url || ''\n\n    // Client options\n    this.statusCode = opts.statusCode || 0\n    this.statusMessage = opts.statusMessage || ''\n  }\n\n  get httpVersion() {\n    return '1.1'\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders() {\n    return { ...this.headers }\n  }\n\n  hasHeader(name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _predestroy() {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst { Writable } = require('bare-stream')\nconst errors = require('./errors')\n\nmodule.exports = class HTTPOutgoingMessage extends Writable {\n  constructor(socket = null) {\n    super()\n\n    this.socket = socket\n    this.headers = {}\n    this.headersSent = false\n    this.upgrade = false\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()]\n  }\n\n  getHeaders() {\n    return { ...this.headers }\n  }\n\n  hasHeader(name) {\n    return name.toLowerCase() in this.headers\n  }\n\n  setHeader(name, value) {\n    this.headers[name.toLowerCase()] = value\n  }\n\n  flushHeaders() {\n    if (this.headersSent === true || this.socket === null) return\n\n    this.socket.write(Buffer.from(this._header()))\n    this.headersSent = true\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ontimeout) this.once('timeout', ontimeout)\n\n    this.socket.setTimeout(ms)\n\n    return this\n  }\n\n  _header() {\n    throw errors.NOT_IMPLEMENTED()\n  }\n\n  _predestroy() {\n    if (this.upgrade === false && this.socket !== null) this.socket.destroy()\n  }\n}\nconst tcp = require('bare-tcp')\nconst { isEnded, isFinished, getStreamError } = require('bare-stream')\nconst HTTPIncomingMessage = require('./incoming-message')\nconst HTTPServerResponse = require('./server-response')\nconst constants = require('./constants')\n\nconst empty = Buffer.alloc(0)\n\nmodule.exports = class HTTPServerConnection {\n  static _connections = new WeakMap()\n\n  static for(socket) {\n    return this._connections.get(socket) || null\n  }\n\n  constructor(server, socket, opts = {}) {\n    const {\n      IncomingMessage = HTTPIncomingMessage,\n      ServerResponse = HTTPServerResponse\n    } = opts\n\n    this.server = server\n    this.socket = socket\n\n    this.req = null\n    this.res = null\n\n    this._IncomingMessage = IncomingMessage\n    this._ServerResponse = ServerResponse\n\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    this._onclose = this._onclose.bind(this)\n    this._ondata = this._ondata.bind(this)\n    this._ondrain = this._ondrain.bind(this)\n    this._ontimeout = this._ontimeout.bind(this)\n\n    socket\n      .on('error', noop)\n      .on('close', this._onclose)\n      .on('data', this._ondata)\n      .on('drain', this._ondrain)\n      .on('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.set(socket, this)\n\n    if (this.server.timeout) socket.setTimeout(this.server.timeout)\n  }\n\n  get idle() {\n    return this._idle\n  }\n\n  _onclose() {\n    if (this.req && !isEnded(this.req)) this.req.destroy()\n    if (this.res && !isFinished(this.res)) this.res.destroy()\n    const err = getStreamError(this.socket)\n    if (err) this.socket.destroy(err)\n  }\n\n  _ondata(data) {\n    this._idle = false\n\n    if (this._state === constants.state.IN_BODY) return this._onbody(data)\n\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    let hits = 0\n\n    for (let i = 0; i < this._buffer.byteLength; i++) {\n      const b = this._buffer[i]\n\n      if (hits === 0 && b === 13) {\n        hits++\n      } else if (hits === 1 && b === 10) {\n        hits++\n\n        if (this._state === constants.state.BEFORE_CHUNK) {\n          const head = this._buffer.subarray(0, i - 1)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunklength(head)\n\n          if (this._buffer === null) break\n        } else if (this._state === constants.state.IN_CHUNK) {\n          const chunk = this._buffer.subarray(0, i - 1)\n\n          if (chunk.byteLength !== this._length) {\n            hits = 0\n            continue\n          }\n\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onchunk(chunk)\n\n          if (this._buffer === null) break\n        }\n      } else if (hits === 2 && b === 13) {\n        hits++\n      } else if (hits === 3 && b === 10) {\n        if (this._state === constants.state.BEFORE_HEAD) {\n          const head = this._buffer.subarray(0, i - 3)\n          this._buffer =\n            i + 1 === this._buffer.byteLength\n              ? null\n              : this._buffer.subarray(i + 1)\n          i = 0\n          hits = 0\n          this._onhead(head)\n\n          if (this._buffer === null) break\n        }\n      } else {\n        hits = 0\n      }\n    }\n  }\n\n  _onhead(data) {\n    this._state = constants.state.IN_HEAD\n\n    const r = data.toString().split('\\r\\n')\n    if (r.length === 0) return this.socket.destroy()\n\n    const [method, url] = r[0].split(' ')\n    if (!method || !url) return this.socket.destroy()\n\n    const headers = {}\n\n    for (let i = 1; i < r.length; i++) {\n      const [name, value] = r[i].split(': ')\n      headers[name.toLowerCase()] = value\n    }\n\n    this.req = new this._IncomingMessage(this.socket, headers, { method, url })\n\n    this.req.on('close', () => {\n      this.req = null\n      this._onreset()\n    })\n\n    this.req.resume()\n    this.req.pause()\n\n    if (headers.connection && headers.connection.toLowerCase() === 'upgrade') {\n      const head = this._buffer\n      this._buffer = null\n      return this._onupgrade(head)\n    }\n\n    this.res = new this._ServerResponse(\n      this.socket,\n      this.req,\n      headers.connection === 'close'\n    )\n\n    this.res.on('close', () => {\n      this.res = null\n    })\n\n    this.server.emit('request', this.req, this.res)\n\n    if (headers['transfer-encoding'] === 'chunked') {\n      this._state = constants.state.BEFORE_CHUNK\n    } else {\n      this._length = parseInt(headers['content-length'], 10) || 0\n\n      if (this._length === 0) return this._onfinished()\n\n      this._state = constants.state.IN_BODY\n\n      if (this._buffer) {\n        const body = this._buffer\n        this._buffer = null\n        this._onbody(body)\n      }\n    }\n  }\n\n  _onchunklength(data) {\n    this._length = parseInt(data.toString(), 16)\n\n    if (this._length === 0) this._onfinished()\n    else this._state = constants.state.IN_CHUNK\n  }\n\n  _onchunk(data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    this._state = constants.state.BEFORE_CHUNK\n  }\n\n  _onbody(data) {\n    this._read += data.byteLength\n\n    this.req.push(data)\n\n    if (this._read === this._length) this._onfinished()\n  }\n\n  _onupgrade(head) {\n    this._ondetach()\n\n    const req = this.req\n\n    req.upgrade = true\n    req.destroy()\n\n    this.server.emit('upgrade', req, this.socket, head || empty)\n  }\n\n  _ontimeout() {\n    const reqTimeout = this.req && this.req.emit('timeout')\n    const resTimeout = this.res && this.res.emit('timeout')\n    const serverTimeout = this.server.emit('timeout', this.socket)\n\n    if (!reqTimeout && !resTimeout && !serverTimeout) this.socket.destroy()\n  }\n\n  _onfinished() {\n    if (this.req) this.req.push(null)\n  }\n\n  _onreset() {\n    this._state = constants.state.BEFORE_HEAD\n    this._length = -1\n    this._read = 0\n    this._buffer = null\n    this._idle = true\n\n    if (this.server._state & tcp.constants.state.CLOSING) {\n      this.socket.destroy()\n    }\n  }\n\n  _ondrain() {\n    if (this.res) this.res._continueWrite()\n  }\n\n  _ondetach() {\n    this.socket\n      .off('error', noop)\n      .off('close', this._onclose)\n      .off('data', this._ondata)\n      .off('drain', this._ondrain)\n      .off('timeout', this._ontimeout)\n\n    HTTPServerConnection._connections.delete(this.socket)\n  }\n}\n\nfunction noop() {}\nconst HTTPOutgoingMessage = require('./outgoing-message')\nconst constants = require('./constants')\n\nmodule.exports = class HTTPServerResponse extends HTTPOutgoingMessage {\n  constructor(socket, req, close) {\n    super(socket)\n\n    this.req = req\n\n    this.statusCode = 200\n    this.statusMessage = null\n\n    this._chunked = true\n    this._close = close\n    this._finishing = false\n    this._onlyHeaders = req.method === 'HEAD'\n\n    this._pendingWrite = null\n  }\n\n  end(data) {\n    this._finishing = true\n    return super.end(data)\n  }\n\n  writeHead(statusCode, statusMessage = null, headers = {}) {\n    if (typeof statusMessage === 'object' && statusMessage !== null) {\n      headers = statusMessage\n      statusMessage = null\n    }\n\n    this.statusCode = statusCode\n    this.statusMessage = statusMessage || null\n    this.headers = headers || {}\n  }\n\n  _header() {\n    let h =\n      'HTTP/1.1 ' +\n      this.statusCode +\n      ' ' +\n      (this.statusMessage === null\n        ? constants.status[this.statusCode]\n        : this.statusMessage) +\n      '\\r\\n'\n\n    for (const name of Object.keys(this.headers)) {\n      const n = name.toLowerCase()\n      const v = this.headers[name]\n\n      if (n === 'content-length') this._chunked = false\n      if (n === 'connection' && v && v.toLowerCase() === 'close')\n        this._close = true\n\n      h += httpCase(n) + ': ' + v + '\\r\\n'\n    }\n\n    if (this._chunked) h += 'Transfer-Encoding: chunked\\r\\n'\n\n    h += '\\r\\n'\n\n    return h\n  }\n\n  _write(data, encoding, cb) {\n    if (this.headersSent === false) {\n      if (this._finishing) {\n        this.setHeader(\n          'Content-Length',\n          (data.byteLength + this._writableState.buffered).toString()\n        )\n      }\n\n      this.flushHeaders()\n    }\n\n    if (this._onlyHeaders === true) return cb(null)\n\n    if (this._chunked) {\n      data = Buffer.concat([\n        Buffer.from('' + data.byteLength.toString(16) + '\\r\\n'),\n        data,\n        Buffer.from('\\r\\n')\n      ])\n    }\n\n    if (this.socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    if (this.headersSent === false) {\n      this.setHeader('Content-Length', '0')\n      this.flushHeaders()\n    }\n\n    if (this._chunked && this._onlyHeaders === false)\n      this.socket.write(Buffer.from('0\\r\\n\\r\\n'))\n    if (this._close) this.socket.end()\n\n    cb(null)\n  }\n\n  _predestroy() {\n    super._predestroy()\n    this.req.destroy()\n    this._continueWrite()\n  }\n\n  _continueWrite() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n}\n\nfunction httpCase(n) {\n  let s = ''\n  for (const part of n.split('-')) {\n    s += (s ? '-' : '') + part.slice(0, 1).toUpperCase() + part.slice(1)\n  }\n  return s\n}\nconst TCPServer = require('bare-tcp').Server\nconst HTTPServerConnection = require('./server-connection')\n\nmodule.exports = class HTTPServer extends TCPServer {\n  constructor(opts = {}, onrequest) {\n    if (typeof opts === 'function') {\n      onrequest = opts\n      opts = {}\n    }\n\n    super({ allowHalfOpen: false })\n\n    this._timeout = 0\n\n    this.on(\n      'connection',\n      (socket) => new HTTPServerConnection(this, socket, opts)\n    )\n\n    if (onrequest) this.on('request', onrequest)\n  }\n\n  get timeout() {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  setTimeout(ms = 0, ontimeout) {\n    if (ontimeout) this.on('timeout', ontimeout)\n\n    this._timeout = ms\n\n    return this\n  }\n\n  close(onclose) {\n    super.close(onclose)\n\n    for (const socket of this._connections) {\n      const connection = HTTPServerConnection.for(socket)\n\n      if (connection && connection.idle) {\n        socket.destroy()\n      }\n    }\n  }\n}\n{\n  \"name\": \"bare-http1\",\n  \"version\": \"4.0.2\",\n  \"description\": \"Native HTTP/1 library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-http1.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-http1/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-http1#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.0.0\",\n    \"bare-stream\": \"^2.3.0\",\n    \"bare-tcp\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nconst tcp = require('bare-tcp')\nconst tls = require('bare-tls')\nconst http = require('bare-http1')\n\nclass HTTPSSocket extends tls.Socket {\n  setKeepAlive(...args) {\n    this.socket.setKeepAlive(...args)\n\n    return this\n  }\n\n  setNoDelay(...args) {\n    this.socket.setNoDelay(...args)\n\n    return this\n  }\n\n  setTimeout(...args) {\n    this.socket.setTimeout(...args)\n\n    return this\n  }\n\n  ref() {\n    this.socket.ref()\n  }\n\n  unref() {\n    this.socket.unref()\n  }\n}\n\nexports.Agent = class HTTPSAgent extends http.Agent {\n  createConnection(opts) {\n    return new HTTPSSocket(super.createConnection(opts), opts)\n  }\n\n  static global = new this({ keepAlive: 1000, timeout: 5000 })\n}\n\nexports.globalAgent = exports.Agent.global\n\nexports.Server = class HTTPSServer extends tcp.Server {\n  constructor(opts = {}, onrequest) {\n    if (typeof opts === 'function') {\n      onrequest = opts\n      opts = {}\n    }\n\n    super({ allowHalfOpen: false })\n\n    this._timeout = 0\n\n    this.on(\n      'connection',\n      (socket) =>\n        new http.ServerConnection(\n          this,\n          new HTTPSSocket(socket, { ...opts, isServer: true }),\n          opts\n        )\n    )\n\n    if (onrequest) this.on('request', onrequest)\n  }\n\n  get timeout() {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  setTimeout(ms = 0, ontimeout) {\n    if (ontimeout) this.on('timeout', ontimeout)\n\n    this._timeout = ms\n\n    return this\n  }\n\n  close(onclose) {\n    super.close(onclose)\n\n    for (const socket of this._connections) {\n      const connection = http.ServerConnection.for(socket)\n\n      if (connection && connection.idle) {\n        socket.destroy()\n      }\n    }\n  }\n}\n\nexports.createServer = function createServer(opts, onrequest) {\n  return new exports.Server(opts, onrequest)\n}\n\nexports.request = function request(url, opts, onresponse) {\n  if (typeof opts === 'function') {\n    onresponse = opts\n    opts = {}\n  }\n\n  if (typeof url === 'string') url = new URL(url)\n\n  if (isURL(url)) {\n    opts = opts ? { ...opts } : {}\n\n    opts.host = url.hostname\n    opts.path = url.pathname + url.search\n    opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n  } else {\n    opts = url ? { ...url } : {}\n\n    // For Node.js compatibility\n    opts.host = opts.hostname || opts.host\n    opts.port =\n      typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n  }\n\n  // TODO: Renable the default global agent when tests have been sorted\n  // opts.agent =\n  //   opts.agent === false\n  //     ? new exports.Agent()\n  //     : opts.agent || exports.Agent.global\n\n  opts.agent = opts.agent || new exports.Agent()\n\n  return new http.ClientRequest(opts, onresponse)\n}\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort(url) {\n  switch (url.protocol) {\n    case 'ftp:':\n      return 21\n    case 'http:':\n    case 'ws:':\n      return 80\n    case 'https:':\n    case 'wss:':\n      return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL(url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\n{\n  \"name\": \"bare-https\",\n  \"version\": \"2.0.0\",\n  \"description\": \"HTTPS library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-https.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-https/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-https#readme\",\n  \"dependencies\": {\n    \"bare-http1\": \"^4.0.0\",\n    \"bare-tcp\": \"^2.0.0\",\n    \"bare-tls\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^4.0.0\",\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nconst EventEmitter = require('bare-events')\nconst { Duplex } = require('bare-stream')\nconst tcp = require('bare-tcp')\nconst pipe = require('bare-pipe')\n\nconst defaultReadBufferSize = 65536\n\nconst constants = (exports.constants = {\n  type: {\n    TCP: 1,\n    IPC: 2\n  },\n  state: {\n    UNREFED: 0x1\n  }\n})\n\nexports.Socket = class NetSocket extends Duplex {\n  constructor(opts = {}) {\n    super({ eagerOpen: true })\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._opts = { readBufferSize, allowHalfOpen }\n    this._type = 0\n    this._state = 0\n    this._socket = null\n\n    this._pendingWrite = null\n    this._pendingFinal = null\n  }\n\n  get connecting() {\n    return this._socket !== null && this._socket.connecting\n  }\n\n  get pending() {\n    return this._socket === null || this._socket.pending\n  }\n\n  connect(...args) {\n    let opts = {}\n    let onconnect\n\n    // connect(path[, onconnect])\n    if (typeof args[0] === 'string') {\n      opts.path = args[0]\n      onconnect = args[1]\n      // connect(port[, host][, onconnect])\n    } else if (typeof args[0] === 'number') {\n      opts.port = args[0]\n\n      if (typeof args[1] === 'function') {\n        onconnect = args[1]\n      } else {\n        opts.host = args[1]\n        onconnect = args[2]\n      }\n      // connect(opts[, onconnect])\n    } else {\n      opts = args[0] || {}\n      onconnect = args[1]\n    }\n\n    opts = { ...opts, ...this._opts }\n\n    if (opts.path) {\n      this._attach(constants.type.IPC, pipe.createConnection(opts))\n    } else {\n      this._attach(constants.type.TCP, tcp.createConnection(opts))\n    }\n\n    if (onconnect) this.once('connect', onconnect)\n\n    return this\n  }\n\n  ref() {\n    this._state &= ~constants.state.UNREFED\n    if (this._socket !== null) this._socket.ref()\n  }\n\n  unref() {\n    this._state |= constants.state.UNREFED\n    if (this._socket !== null) this._socket.unref()\n  }\n\n  _attach(type, socket) {\n    this._type = type\n    this._socket = socket\n\n    this._socket\n      .on('connect', this._onconnect.bind(this))\n      .on('error', this._onerror.bind(this))\n      .on('close', this._onclose.bind(this))\n      .on('end', this._onend.bind(this))\n      .on('data', this._ondata.bind(this))\n      .on('drain', this._ondrain.bind(this))\n\n    if (this._state & constants.state.UNREFED) this._socket.unref()\n\n    return this\n  }\n\n  _write(data, encoding, cb) {\n    if (this._socket !== null && this._socket.write(data)) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    if (this._socket === null) return cb(null)\n    this._pendingFinal = cb\n    this._socket.end()\n  }\n\n  _predestroy() {\n    if (this._socket === null) return\n    this._socket.destroy()\n  }\n\n  _onconnect() {\n    this._ondrain() // Flush any pending writes\n\n    this.emit('connect')\n  }\n\n  _onerror(err) {\n    this.destroy(err)\n  }\n\n  _onend() {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(null)\n  }\n\n  _onclose() {\n    this.push(null)\n  }\n\n  _ondata(data) {\n    this.push(data)\n  }\n\n  _ondrain() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n}\n\nexports.Server = class NetServer extends EventEmitter {\n  constructor(opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._opts = { readBufferSize, allowHalfOpen }\n    this._type = 0\n    this._state = 0\n    this._server = null\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening() {\n    return this._server !== null && this._server.listening\n  }\n\n  address() {\n    return this._server === null ? null : this._server.address()\n  }\n\n  listen(...args) {\n    let opts = {}\n    let onlistening\n\n    // listen(path[, backlog][, onlistening])\n    if (typeof args[0] === 'string') {\n      opts.path = args[0]\n\n      if (typeof args[1] === 'function') {\n        onlistening = args[1]\n      } else {\n        opts.backlog = args[1]\n        onlistening = args[2]\n      }\n      // listen([port[, host[, backlog]]][, onlistening])\n    } else {\n      if (typeof args[0] === 'function') {\n        onlistening = args[0]\n      } else {\n        opts.port = args[0]\n\n        if (typeof args[1] === 'function') {\n          onlistening = args[1]\n        } else {\n          opts.host = args[1]\n\n          if (typeof args[2] === 'function') {\n            onlistening = args[2]\n          } else {\n            opts.backlog = args[2]\n            onlistening = args[3]\n          }\n        }\n      }\n    }\n\n    opts = { ...opts, ...this._opts }\n\n    if (opts.path) {\n      this._attach(constants.type.IPC, pipe.createServer(opts))\n    } else {\n      this._attach(constants.type.TCP, tcp.createServer(opts))\n    }\n\n    this._server.listen(opts)\n\n    if (onlistening) this.once('listening', onlistening)\n\n    return this\n  }\n\n  close(onclose) {\n    if (onclose) this.once('close', onclose)\n    this._server.close()\n  }\n\n  ref() {\n    this._state &= ~constants.state.UNREFED\n    if (this._server !== null) this._server.ref()\n  }\n\n  unref() {\n    this._state |= constants.state.UNREFED\n    if (this._server !== null) this._server.unref()\n  }\n\n  _attach(type, server) {\n    this._type = type\n    this._server = server\n\n    this._server\n      .on('listening', this._onlistening.bind(this))\n      .on('connection', this._onconnection.bind(this))\n      .on('error', this._onerror.bind(this))\n      .on('close', this._onclose.bind(this))\n\n    if (this._state & constants.state.UNREFED) this._server.unref()\n\n    return this\n  }\n\n  _onlistening() {\n    this.emit('listening')\n  }\n\n  _onconnection(socket) {\n    this.emit(\n      'connection',\n      new exports.Socket(this._opts)._attach(this._type, socket)\n    )\n  }\n\n  _onerror(err) {\n    this.emit('error', err)\n  }\n\n  _onclose() {\n    this.emit('close')\n  }\n}\n\nexports.isIP = tcp.isIP\nexports.isIPv4 = tcp.isIPv4\nexports.isIPv6 = tcp.isIPv6\n\nexports.createConnection = function createConnection(...args) {\n  let opts = {}\n  let onconnect\n\n  // createConnection(path[, onconnect])\n  if (typeof args[0] === 'string') {\n    opts.path = args[0]\n    onconnect = args[1]\n    // createConnection(port[, host][, onconnect])\n  } else if (typeof args[0] === 'number') {\n    opts.port = args[0]\n\n    if (typeof args[1] === 'function') {\n      onconnect = args[1]\n    } else {\n      opts.host = args[1]\n      onconnect = args[2]\n    }\n    // createConnection(opts[, onconnect])\n  } else {\n    opts = args[0] || {}\n    onconnect = args[1]\n  }\n\n  return new exports.Socket(opts).connect(opts, onconnect)\n}\n\n// For Node.js compatibility\nexports.connect = exports.createConnection\n\nexports.createServer = function createServer(opts, onconnection) {\n  return new exports.Server(opts, onconnection)\n}\n{\n  \"name\": \"bare-net\",\n  \"version\": \"2.0.1\",\n  \"description\": \"TCP and IPC servers and clients for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-net.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-net/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-net#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.2.2\",\n    \"bare-pipe\": \"^4.0.0\",\n    \"bare-stream\": \"^2.0.0\",\n    \"bare-tcp\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require.addon()\nconst binding = require('./binding')\nconst errors = require('./lib/errors')\nconst constants = require('./lib/constants')\n\nexports.constants = constants\n\nexports.EOL = binding.platform === 'win32' ? '\\r\\n' : '\\n'\n\nexports.platform = function platform() {\n  return binding.platform\n}\n\nexports.arch = function arch() {\n  return binding.arch\n}\n\nexports.type = binding.type\nexports.version = binding.version\nexports.release = binding.release\nexports.machine = binding.machine\nexports.execPath = binding.execPath\nexports.pid = binding.pid\nexports.ppid = binding.ppid\nexports.cwd = binding.cwd\nexports.chdir = binding.chdir\nexports.tmpdir = binding.tmpdir\nexports.homedir = binding.homedir\nexports.hostname = binding.hostname\n\nexports.kill = function kill(pid, signal = constants.signals.SIGTERM) {\n  if (typeof signal === 'string') {\n    if (signal in constants.signals === false) {\n      throw errors.UNKNOWN_SIGNAL('Unknown signal: ' + signal)\n    }\n\n    signal = constants.signals[signal]\n  }\n\n  binding.kill(pid, signal)\n}\n\nexports.endianness = function endianness() {\n  return binding.isLittleEndian ? 'LE' : 'BE'\n}\n\nexports.availableParallelism = binding.availableParallelism\n\nexports.cpuUsage = function cpuUsage(previous) {\n  const current = binding.cpuUsage()\n\n  if (previous) {\n    return {\n      user: current.user - previous.user,\n      system: current.system - previous.system\n    }\n  }\n\n  return current\n}\n\nexports.threadCpuUsage = function threadCpuUsage(previous) {\n  const current = binding.threadCpuUsage()\n\n  if (previous) {\n    return {\n      user: current.user - previous.user,\n      system: current.system - previous.system\n    }\n  }\n\n  return current\n}\n\nexports.resourceUsage = binding.resourceUsage\nexports.memoryUsage = binding.memoryUsage\nexports.freemem = binding.freemem\nexports.totalmem = binding.totalmem\nexports.uptime = binding.uptime\nexports.loadavg = binding.loadavg\nexports.cpus = binding.cpus\n\nexports.getProcessTitle = binding.getProcessTitle\n\nexports.setProcessTitle = function setProcessTitle(title) {\n  if (typeof title !== 'string') title = title.toString()\n\n  if (title.length >= 256) {\n    throw errors.TITLE_OVERFLOW('Process title is too long')\n  }\n\n  binding.setProcessTitle(title)\n}\n\nexports.getEnvKeys = binding.getEnvKeys\nexports.getEnv = binding.getEnv\nexports.hasEnv = binding.hasEnv\nexports.setEnv = binding.setEnv\nexports.unsetEnv = binding.unsetEnv\nconst binding = require('../binding')\n\nmodule.exports = {\n  signals: binding.signals,\n  errnos: binding.errnos\n}\nmodule.exports = class OSError extends Error {\n  constructor(msg, code, fn = OSError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'OSError'\n  }\n\n  static UNKNOWN_SIGNAL(msg) {\n    return new OSError(msg, 'UNKNOWN_SIGNAL', OSError.UNKNOWN_SIGNAL)\n  }\n\n  static TITLE_OVERFLOW(msg) {\n    return new OSError(msg, 'TITLE_OVERFLOW', OSError.TITLE_OVERFLOW)\n  }\n}\n{\n  \"name\": \"bare-os\",\n  \"version\": \"3.5.1\",\n  \"description\": \"Operating system utilities for Javascript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-os.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-os/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-os#readme\",\n  \"engines\": {\n    \"bare\": \">=1.14.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\n/* global Bare */\n\n// This export SHOULD NOT be shortened in any way as having the full\n// `module.exports = require(...)` statement is crucial for synthesizing\n// ESM exports.\n\nif (Bare.platform === 'win32') {\n  module.exports = require('./lib/win32')\n} else {\n  module.exports = require('./lib/posix')\n}\nmodule.exports = {\n  CHAR_UPPERCASE_A: 0x41,\n  CHAR_LOWERCASE_A: 0x61,\n  CHAR_UPPERCASE_Z: 0x5a,\n  CHAR_LOWERCASE_Z: 0x7a,\n  CHAR_DOT: 0x2e,\n  CHAR_FORWARD_SLASH: 0x2f,\n  CHAR_BACKWARD_SLASH: 0x5c,\n  CHAR_COLON: 0x3a,\n  CHAR_QUESTION_MARK: 0x3f\n}\nconst os = require('bare-os')\n\nconst { normalizeString } = require('./shared')\nconst {\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH\n} = require('./constants')\n\nfunction isPosixPathSeparator (code) {\n  return code === CHAR_FORWARD_SLASH\n}\n\nexports.win32 = require('./win32')\nexports.posix = exports\n\nexports.sep = '/'\nexports.delimiter = ':'\n\nexports.resolve = function resolve (...args) {\n  let resolvedPath = ''\n  let resolvedAbsolute = false\n\n  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? args[i] : os.cwd()\n\n    if (path.length === 0) {\n      continue\n    }\n\n    resolvedPath = `${path}/${resolvedPath}`\n    resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  }\n\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator)\n\n  if (resolvedAbsolute) {\n    return `/${resolvedPath}`\n  }\n\n  return resolvedPath.length > 0 ? resolvedPath : '.'\n}\n\nexports.normalize = function normalize (path) {\n  if (path.length === 0) return '.'\n\n  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH\n\n  path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator)\n\n  if (path.length === 0) {\n    if (isAbsolute) return '/'\n    return trailingSeparator ? './' : '.'\n  }\n\n  if (trailingSeparator) path += '/'\n\n  return isAbsolute ? `/${path}` : path\n}\n\nexports.isAbsolute = function isAbsolute (path) {\n  return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH\n}\n\nexports.join = function join (...args) {\n  if (args.length === 0) return '.'\n  let joined\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i]\n    if (arg.length > 0) {\n      if (joined === undefined) joined = arg\n      else joined += `/${arg}`\n    }\n  }\n  if (joined === undefined) return '.'\n  return exports.normalize(joined)\n}\n\nexports.relative = function relative (from, to) {\n  if (from === to) return ''\n\n  from = exports.resolve(from)\n  to = exports.resolve(to)\n\n  if (from === to) return ''\n\n  const fromStart = 1\n  const fromEnd = from.length\n  const fromLen = fromEnd - fromStart\n  const toStart = 1\n  const toLen = to.length - toStart\n\n  const length = (fromLen < toLen ? fromLen : toLen)\n  let lastCommonSep = -1\n  let i = 0\n  for (; i < length; i++) {\n    const fromCode = from.charCodeAt(fromStart + i)\n    if (fromCode !== to.charCodeAt(toStart + i)) {\n      break\n    } else if (fromCode === CHAR_FORWARD_SLASH) {\n      lastCommonSep = i\n    }\n  }\n  if (i === length) {\n    if (toLen > length) {\n      if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n        return to.substring(toStart + i + 1)\n      }\n      if (i === 0) {\n        return to.substring(toStart + i)\n      }\n    } else if (fromLen > length) {\n      if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i\n      } else if (i === 0) {\n        lastCommonSep = 0\n      }\n    }\n  }\n\n  let out = ''\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      out += out.length === 0 ? '..' : '/..'\n    }\n  }\n\n  return `${out}${to.substring(toStart + lastCommonSep)}`\n}\n\nexports.toNamespacedPath = function toNamespacedPath (path) {\n  return path\n}\n\nexports.dirname = function dirname (path) {\n  if (path.length === 0) return '.'\n  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH\n  let end = -1\n  let matchedSlash = true\n  for (let i = path.length - 1; i >= 1; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        end = i\n        break\n      }\n    } else {\n      matchedSlash = false\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.'\n  if (hasRoot && end === 1) return '//'\n  return path.substring(0, end)\n}\n\nexports.basename = function basename (path, suffix) {\n  let start = 0\n  let end = -1\n  let matchedSlash = true\n\n  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n    if (suffix === path) { return '' }\n    let extIdx = suffix.length - 1\n    let firstNonSlashEnd = -1\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i)\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1\n          break\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          matchedSlash = false\n          firstNonSlashEnd = i + 1\n        }\n        if (extIdx >= 0) {\n          if (code === suffix.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              end = i\n            }\n          } else {\n            extIdx = -1\n            end = firstNonSlashEnd\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd\n    else if (end === -1) end = path.length\n    return path.substring(start, end)\n  }\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        start = i + 1\n        break\n      }\n    } else if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n  }\n\n  if (end === -1) return ''\n  return path.substring(start, end)\n}\n\nexports.extname = function extname (path) {\n  let startDot = -1\n  let startPart = 0\n  let end = -1\n  let matchedSlash = true\n  let preDotState = 0\n  for (let i = path.length - 1; i >= 0; --i) {\n    const code = path.charCodeAt(i)\n    if (code === CHAR_FORWARD_SLASH) {\n      if (!matchedSlash) {\n        startPart = i + 1\n        break\n      }\n      continue\n    }\n    if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n    if (code === CHAR_DOT) {\n      if (startDot === -1) startDot = i\n      else if (preDotState !== 1) preDotState = 1\n    } else if (startDot !== -1) {\n      preDotState = -1\n    }\n  }\n\n  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n    return ''\n  }\n  return path.substring(startDot, end)\n}\nconst {\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH\n} = require('./constants')\n\nexports.normalizeString = function normalizeString (path, allowAboveRoot, separator, isPathSeparator) {\n  let res = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let code = 0\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i)\n    } else if (isPathSeparator(code)) {\n      break\n    } else {\n      code = CHAR_FORWARD_SLASH\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) ;\n      else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator)\n            if (lastSlashIndex === -1) {\n              res = ''\n              lastSegmentLength = 0\n            } else {\n              res = res.substring(0, lastSlashIndex)\n              lastSegmentLength =\n                res.length - 1 - res.lastIndexOf(separator)\n            }\n            lastSlash = i\n            dots = 0\n            continue\n          } else if (res.length !== 0) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.substring(lastSlash + 1, i)}`\n        } else {\n          res = path.substring(lastSlash + 1, i)\n        }\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\nconst os = require('bare-os')\n\nconst { normalizeString } = require('./shared')\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK\n} = require('./constants')\n\nfunction isWindowsPathSeparator (code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH\n}\n\nfunction isWindowsDeviceRoot (code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z)\n}\n\nexports.posix = require('./posix')\nexports.win32 = exports\n\nexports.sep = '\\\\'\nexports.delimiter = ';'\n\nexports.resolve = function resolve (...args) {\n  let resolvedDevice = ''\n  let resolvedTail = ''\n  let resolvedAbsolute = false\n\n  for (let i = args.length - 1; i >= -1; i--) {\n    let path\n    if (i >= 0) {\n      path = args[i]\n\n      if (path.length === 0) continue\n    } else if (resolvedDevice.length === 0) {\n      path = os.cwd()\n    } else {\n      path = os.getEnv(`=${resolvedDevice}`) || os.cwd()\n\n      if (path === undefined || (path.substring(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n        path = `${resolvedDevice}\\\\`\n      }\n    }\n\n    const len = path.length\n    let rootEnd = 0\n    let device = ''\n    let isAbsolute = false\n    const code = path.charCodeAt(0)\n\n    if (len === 1) {\n      if (isWindowsPathSeparator(code)) {\n        rootEnd = 1\n        isAbsolute = true\n      }\n    } else if (isWindowsPathSeparator(code)) {\n      isAbsolute = true\n\n      if (isWindowsPathSeparator(path.charCodeAt(1))) {\n        let j = 2\n        let last = j\n        while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.substring(last, j)\n          last = j\n          while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j < len && j !== last) {\n            last = j\n            while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n              j++\n            }\n            if (j === len || j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${path.substring(last, j)}`\n              rootEnd = j\n            }\n          }\n        }\n      } else {\n        rootEnd = 1\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      device = path.substring(0, 2)\n      rootEnd = 2\n      if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {\n        isAbsolute = true\n        rootEnd = 3\n      }\n    }\n\n    if (device.length > 0) {\n      if (resolvedDevice.length > 0) {\n        if (device.toLowerCase() !== resolvedDevice.toLowerCase()) { continue }\n      } else {\n        resolvedDevice = device\n      }\n    }\n\n    if (resolvedAbsolute) {\n      if (resolvedDevice.length > 0) { break }\n    } else {\n      resolvedTail = `${path.substring(rootEnd)}\\\\${resolvedTail}`\n      resolvedAbsolute = isAbsolute\n      if (isAbsolute && resolvedDevice.length > 0) {\n        break\n      }\n    }\n  }\n\n  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isWindowsPathSeparator)\n\n  return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || '.'\n}\n\nexports.normalize = function normalize (path) {\n  const len = path.length\n  if (len === 0) return '.'\n  let rootEnd = 0\n  let device\n  let isAbsolute = false\n  const code = path.charCodeAt(0)\n\n  if (len === 1) {\n    return code === CHAR_FORWARD_SLASH ? '\\\\' : path\n  }\n\n  if (isWindowsPathSeparator(code)) {\n    isAbsolute = true\n\n    if (isWindowsPathSeparator(path.charCodeAt(1))) {\n      let j = 2\n      let last = j\n      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n        j++\n      }\n      if (j < len && j !== last) {\n        const firstPart = path.substring(last, j)\n        last = j\n        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          last = j\n          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j === len) {\n            return `\\\\\\\\${firstPart}\\\\${path.substring(last)}\\\\`\n          }\n          if (j !== last) {\n            device = `\\\\\\\\${firstPart}\\\\${path.substring(last, j)}`\n            rootEnd = j\n          }\n        }\n      }\n    } else {\n      rootEnd = 1\n    }\n  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n    device = path.substring(0, 2)\n    rootEnd = 2\n    if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {\n      isAbsolute = true\n      rootEnd = 3\n    }\n  }\n\n  let tail = rootEnd < len ? normalizeString(path.substring(rootEnd), !isAbsolute, '\\\\', isWindowsPathSeparator) : ''\n  if (tail.length === 0 && !isAbsolute) {\n    tail = '.'\n  }\n  if (tail.length > 0 && isWindowsPathSeparator(path.charCodeAt(len - 1))) {\n    tail += '\\\\'\n  }\n  if (device === undefined) {\n    return isAbsolute ? `\\\\${tail}` : tail\n  }\n  return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`\n}\n\nexports.isAbsolute = function isAbsolute (path) {\n  const len = path.length\n  if (len === 0) return false\n\n  const code = path.charCodeAt(0)\n\n  return isWindowsPathSeparator(code) || (len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isWindowsPathSeparator(path.charCodeAt(2)))\n}\n\nexports.join = function join (...args) {\n  if (args.length === 0) return '.'\n\n  let joined\n  let firstPart\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i]\n    if (arg.length > 0) {\n      if (joined === undefined) joined = firstPart = arg\n      else joined += `\\\\${arg}`\n    }\n  }\n\n  if (joined === undefined) return '.'\n\n  let needsReplace = true\n  let slashCount = 0\n  if (isWindowsPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount\n    const firstLen = firstPart.length\n    if (firstLen > 1 && isWindowsPathSeparator(firstPart.charCodeAt(1))) {\n      ++slashCount\n      if (firstLen > 2) {\n        if (isWindowsPathSeparator(firstPart.charCodeAt(2))) {\n          ++slashCount\n        } else {\n          needsReplace = false\n        }\n      }\n    }\n  }\n  if (needsReplace) {\n    while (slashCount < joined.length && isWindowsPathSeparator(joined.charCodeAt(slashCount))) {\n      slashCount++\n    }\n\n    if (slashCount >= 2) {\n      joined = `\\\\${joined.substring(slashCount)}`\n    }\n  }\n\n  return exports.normalize(joined)\n}\n\nexports.relative = function relative (from, to) {\n  if (from === to) return ''\n\n  const fromOrig = exports.resolve(from)\n  const toOrig = exports.resolve(to)\n\n  if (fromOrig === toOrig) return ''\n\n  from = fromOrig.toLowerCase()\n  to = toOrig.toLowerCase()\n\n  if (from === to) return ''\n\n  let fromStart = 0\n  while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n    fromStart++\n  }\n  let fromEnd = from.length\n  while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n    fromEnd--\n  }\n  const fromLen = fromEnd - fromStart\n\n  let toStart = 0\n  while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n    toStart++\n  }\n  let toEnd = to.length\n  while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n    toEnd--\n  }\n  const toLen = toEnd - toStart\n\n  const length = fromLen < toLen ? fromLen : toLen\n  let lastCommonSep = -1\n  let i = 0\n  for (; i < length; i++) {\n    const fromCode = from.charCodeAt(fromStart + i)\n    if (fromCode !== to.charCodeAt(toStart + i)) {\n      break\n    } else if (fromCode === CHAR_BACKWARD_SLASH) {\n      lastCommonSep = i\n    }\n  }\n\n  if (i !== length) {\n    if (lastCommonSep === -1) return toOrig\n  } else {\n    if (toLen > length) {\n      if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n        return toOrig.substring(toStart + i + 1)\n      }\n      if (i === 2) {\n        return toOrig.substring(toStart + i)\n      }\n    }\n    if (fromLen > length) {\n      if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i\n      } else if (i === 2) {\n        lastCommonSep = 3\n      }\n    }\n    if (lastCommonSep === -1) lastCommonSep = 0\n  }\n\n  let out = ''\n  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      out += out.length === 0 ? '..' : '\\\\..'\n    }\n  }\n\n  toStart += lastCommonSep\n\n  if (out.length > 0) {\n    return `${out}${toOrig.substring(toStart, toEnd)}`\n  }\n  if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n    ++toStart\n  }\n  return toOrig.substring(toStart, toEnd)\n}\n\nexports.toNamespacedPath = function toNamespacedPath (path) {\n  if (path.length === 0) return path\n\n  const resolvedPath = exports.resolve(path)\n\n  if (resolvedPath.length <= 2) return path\n\n  if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n    if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n      const code = resolvedPath.charCodeAt(2)\n      if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n        return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.substring(2)}`\n      }\n    }\n  } else if (\n    isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n      resolvedPath.charCodeAt(1) === CHAR_COLON &&\n      resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH\n  ) {\n    return `\\\\\\\\?\\\\${resolvedPath}`\n  }\n\n  return path\n}\n\nexports.dirname = function dirname (path) {\n  const len = path.length\n  if (len === 0) return '.'\n  let rootEnd = -1\n  let offset = 0\n  const code = path.charCodeAt(0)\n\n  if (len === 1) {\n    return isWindowsPathSeparator(code) ? path : '.'\n  }\n\n  if (isWindowsPathSeparator(code)) {\n    rootEnd = offset = 1\n\n    if (isWindowsPathSeparator(path.charCodeAt(1))) {\n      let j = 2\n      let last = j\n      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n        j++\n      }\n      if (j < len && j !== last) {\n        last = j\n        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {\n          j++\n        }\n        if (j < len && j !== last) {\n          last = j\n          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {\n            j++\n          }\n          if (j === len) {\n            return path\n          }\n          if (j !== last) {\n            rootEnd = offset = j + 1\n          }\n        }\n      }\n    }\n  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n    rootEnd = len > 2 && isWindowsPathSeparator(path.charCodeAt(2)) ? 3 : 2\n    offset = rootEnd\n  }\n\n  let end = -1\n  let matchedSlash = true\n  for (let i = len - 1; i >= offset; --i) {\n    if (isWindowsPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i\n        break\n      }\n    } else {\n      matchedSlash = false\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1) return '.'\n\n    end = rootEnd\n  }\n  return path.substring(0, end)\n}\n\nexports.basename = function basename (path, suffix) {\n  let start = 0\n  let end = -1\n  let matchedSlash = true\n\n  if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {\n    start = 2\n  }\n\n  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n    if (suffix === path) return ''\n    let extIdx = suffix.length - 1\n    let firstNonSlashEnd = -1\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i)\n      if (isWindowsPathSeparator(code)) {\n        if (!matchedSlash) {\n          start = i + 1\n          break\n        }\n      } else {\n        if (firstNonSlashEnd === -1) {\n          matchedSlash = false\n          firstNonSlashEnd = i + 1\n        }\n        if (extIdx >= 0) {\n          if (code === suffix.charCodeAt(extIdx)) {\n            if (--extIdx === -1) {\n              end = i\n            }\n          } else {\n            extIdx = -1\n            end = firstNonSlashEnd\n          }\n        }\n      }\n    }\n\n    if (start === end) end = firstNonSlashEnd\n    else if (end === -1) end = path.length\n    return path.substring(start, end)\n  }\n  for (let i = path.length - 1; i >= start; --i) {\n    if (isWindowsPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        start = i + 1\n        break\n      }\n    } else if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n  }\n\n  if (end === -1) return ''\n  return path.substring(start, end)\n}\n\nexports.extname = function extname (path) {\n  let start = 0\n  let startDot = -1\n  let startPart = 0\n  let end = -1\n  let matchedSlash = true\n  let preDotState = 0\n\n  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n    start = startPart = 2\n  }\n\n  for (let i = path.length - 1; i >= start; --i) {\n    const code = path.charCodeAt(i)\n    if (isWindowsPathSeparator(code)) {\n      if (!matchedSlash) {\n        startPart = i + 1\n        break\n      }\n      continue\n    }\n    if (end === -1) {\n      matchedSlash = false\n      end = i + 1\n    }\n    if (code === CHAR_DOT) {\n      if (startDot === -1) startDot = i\n      else if (preDotState !== 1) preDotState = 1\n    } else if (startDot !== -1) {\n      preDotState = -1\n    }\n  }\n\n  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {\n    return ''\n  }\n  return path.substring(startDot, end)\n}\n{\n  \"name\": \"bare-path\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Path manipulation library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./posix\": \"./lib/posix.js\",\n    \"./win32\": \"./lib/win32.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\",\n    \"NOTICE\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-path.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-path/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-path#readme\",\n  \"dependencies\": {\n    \"bare-os\": \"^3.0.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst { Duplex } = require('bare-stream')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\n\nconst defaultReadBufferSize = 65536\n\nmodule.exports = exports = class Pipe extends Duplex {\n  constructor(path, opts = {}) {\n    super({ eagerOpen: true })\n\n    if (typeof path === 'object' && path !== null) {\n      opts = path\n      path = null\n    }\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._allowHalfOpen = allowHalfOpen\n\n    this._fd = -1\n    this._path = null\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n    this._pendingFinal = null\n    this._pendingDestroy = null\n\n    this._buffer = Buffer.alloc(readBufferSize)\n\n    this._handle = binding.init(\n      this._buffer,\n      this,\n      noop,\n      this._onconnect,\n      this._onwrite,\n      this._onfinal,\n      this._onread,\n      this._onclose\n    )\n\n    if (typeof path === 'number') {\n      this.open(path)\n    } else if (typeof path === 'string') {\n      this.connect(path)\n    }\n  }\n\n  get connecting() {\n    return (this._state & constants.state.CONNECTING) !== 0\n  }\n\n  get pending() {\n    return (this._state & constants.state.CONNECTED) === 0\n  }\n\n  get readyState() {\n    if (\n      this._state & constants.state.READABLE &&\n      this._state & constants.state.WRITABLE\n    ) {\n      return 'open'\n    }\n\n    if (this._state & constants.state.READABLE) {\n      return 'readOnly'\n    }\n\n    if (this._state & constants.state.WRITABLE) {\n      return 'writeOnly'\n    }\n\n    return 'opening'\n  }\n\n  open(fd, opts = {}, onconnect) {\n    if (typeof opts === 'function') {\n      onconnect = opts\n      opts = {}\n    }\n\n    if (typeof fd === 'object' && fd !== null) {\n      opts = fd || {}\n      fd = opts.fd\n    }\n\n    try {\n      const status = binding.open(this._handle, fd)\n\n      this._state |= constants.state.CONNECTED\n      this._fd = fd\n\n      if (status & binding.READABLE) {\n        this._state |= constants.state.READABLE\n      } else {\n        this.push(null)\n      }\n\n      if (status & binding.WRITABLE) {\n        this._state |= constants.state.WRITABLE\n      } else {\n        this.end()\n      }\n\n      if (onconnect) this.once('connect', onconnect)\n\n      queueMicrotask(() => this.emit('connect'))\n    } catch (err) {\n      queueMicrotask(() => {\n        if (this._pendingOpen) this._pendingOpen(err)\n        else this.destroy(err)\n      })\n    }\n\n    return this\n  }\n\n  connect(path, opts = {}, onconnect) {\n    if (\n      this._state & constants.state.CONNECTING ||\n      this._state & constants.state.CONNECTED\n    ) {\n      throw errors.PIPE_ALREADY_CONNECTED('Pipe is already connected')\n    }\n\n    this._state |= constants.state.CONNECTING\n\n    if (typeof opts === 'function') {\n      onconnect = opts\n      opts = {}\n    }\n\n    if (typeof path === 'object' && path !== null) {\n      opts = path || {}\n      path = opts.path\n    }\n\n    try {\n      binding.connect(this._handle, path)\n\n      this._path = path\n\n      if (onconnect) this.once('connect', onconnect)\n    } catch (err) {\n      queueMicrotask(() => {\n        if (this._pendingOpen) this._pendingOpen(err)\n        else this.destroy(err)\n      })\n    }\n\n    return this\n  }\n\n  ref() {\n    binding.ref(this._handle)\n  }\n\n  unref() {\n    binding.unref(this._handle)\n  }\n\n  _open(cb) {\n    if (this._state & constants.state.CONNECTED) return cb(null)\n    this._pendingOpen = cb\n  }\n\n  _read() {\n    if ((this._state & constants.state.READING) === 0) {\n      this._state |= constants.state.READING\n      binding.resume(this._handle)\n    }\n  }\n\n  _writev(batch, cb) {\n    this._pendingWrite = [cb, batch]\n    binding.writev(\n      this._handle,\n      batch.map(({ chunk }) => chunk)\n    )\n  }\n\n  _final(cb) {\n    if (\n      this._state & constants.state.READABLE &&\n      this._state & constants.state.WRITABLE\n    ) {\n      this._pendingFinal = cb\n      binding.end(this._handle)\n    } else {\n      cb(null)\n    }\n  }\n\n  _predestroy() {\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    binding.close(this._handle)\n  }\n\n  _destroy(err, cb) {\n    if (this._state & constants.state.CLOSING) return cb(err)\n    this._state |= constants.state.CLOSING\n    this._pendingDestroy = cb\n    binding.close(this._handle)\n  }\n\n  _continueOpen(err) {\n    if (this._pendingOpen === null) return\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(err)\n  }\n\n  _continueWrite(err) {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite[0]\n    this._pendingWrite = null\n    cb(err)\n  }\n\n  _continueFinal(err) {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(err)\n  }\n\n  _continueDestroy() {\n    if (this._pendingDestroy === null) return\n    const cb = this._pendingDestroy\n    this._pendingDestroy = null\n    cb(null)\n  }\n\n  _onconnect(err) {\n    if (err) {\n      if (this._pendingOpen) this._continueOpen(err)\n      else this.destroy(err)\n      return\n    }\n\n    this._state |=\n      constants.state.CONNECTED |\n      constants.state.READABLE |\n      constants.state.WRITABLE\n    this._state &= ~constants.state.CONNECTING\n    this._continueOpen()\n\n    this.emit('connect')\n  }\n\n  _onread(err, read) {\n    if (err) {\n      this.destroy(err)\n      return\n    }\n\n    if (read === 0) {\n      this.push(null)\n      if (this._allowHalfOpen === false) this.end()\n      return\n    }\n\n    const copy = Buffer.allocUnsafe(read)\n    copy.set(this._buffer.subarray(0, read))\n\n    if (this.push(copy) === false && this.destroying === false) {\n      this._state &= ~constants.state.READING\n      binding.pause(this._handle)\n    }\n  }\n\n  _onwrite(err) {\n    this._continueWrite(err)\n  }\n\n  _onfinal(err) {\n    this._continueFinal(err)\n  }\n\n  _onclose() {\n    this._handle = null\n    this._continueDestroy()\n  }\n\n  _onspawn(readable, writable) {\n    this._state |= constants.state.CONNECTED\n\n    if (readable) {\n      this._state |= constants.state.READABLE\n    } else {\n      this.push(null)\n    }\n\n    if (writable) {\n      this._state |= constants.state.WRITABLE\n    } else {\n      this.end()\n    }\n\n    this._continueOpen()\n  }\n}\n\nexports.Pipe = exports\n\nexports.pipe = function pipe() {\n  return binding.pipe()\n}\n\nexports.Server = class PipeServer extends EventEmitter {\n  constructor(opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._readBufferSize = readBufferSize\n    this._allowHalfOpen = allowHalfOpen\n\n    this._path = null\n    this._connections = new Set()\n\n    this._error = null\n    this._handle = null\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening() {\n    return (this._state & constants.state.BOUND) !== 0\n  }\n\n  address() {\n    if ((this._state & constants.state.BOUND) === 0) {\n      return null\n    }\n\n    return this._path\n  }\n\n  listen(path, backlog = 511, opts = {}, onlistening) {\n    if (\n      this._state & constants.state.BINDING ||\n      this._state & constants.state.BOUND\n    ) {\n      throw errors.SERVER_ALREADY_LISTENING('Server is already listening')\n    }\n\n    if (this._state & constants.state.CLOSING) {\n      throw errors.SERVER_IS_CLOSED('Server is closed')\n    }\n\n    this._state |= constants.state.BINDING\n\n    if (typeof backlog === 'function') {\n      onlistening = backlog\n      backlog = 511\n    } else if (typeof opts === 'function') {\n      onlistening = opts\n      opts = {}\n    }\n\n    if (typeof path === 'object' && path !== null) {\n      opts = path || {}\n      path = opts.path\n      backlog = opts.backlog || 511\n    }\n\n    this._handle = binding.init(\n      empty,\n      this,\n      this._onconnection,\n      noop,\n      noop,\n      noop,\n      noop,\n      this._onclose\n    )\n\n    if (this._state & constants.state.UNREFED) binding.unref(this._handle)\n\n    try {\n      binding.bind(this._handle, path, backlog)\n\n      this._path = path\n      this._state |= constants.state.BOUND\n      this._state &= ~constants.state.BINDING\n\n      if (onlistening) this.once('listening', onlistening)\n\n      queueMicrotask(() => this.emit('listening'))\n    } catch (err) {\n      this._error = err\n\n      binding.close(this._handle)\n    }\n\n    return this\n  }\n\n  close(onclose) {\n    if (onclose) this.once('close', onclose)\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    this._closeMaybe()\n  }\n\n  ref() {\n    this._state &= ~constants.state.UNREFED\n    if (this._handle !== null) binding.ref(this._handle)\n  }\n\n  unref() {\n    this._state |= constants.state.UNREFED\n    if (this._handle !== null) binding.unref(this._handle)\n  }\n\n  _closeMaybe() {\n    if (this._state & constants.state.CLOSING && this._connections.size === 0) {\n      if (this._handle !== null) binding.close(this._handle)\n      else queueMicrotask(() => this.emit('close'))\n    }\n  }\n\n  _onconnection(err) {\n    if (err) {\n      this.emit('error', err)\n      return\n    }\n\n    if (this._state & constants.state.CLOSING) return\n\n    const pipe = new exports.Pipe({\n      readBufferSize: this._readBufferSize,\n      allowHalfOpen: this._allowHalfOpen\n    })\n\n    try {\n      binding.accept(this._handle, pipe._handle)\n\n      pipe._path = this._path\n      pipe._state |=\n        constants.state.CONNECTED |\n        constants.state.READABLE |\n        constants.state.WRITABLE\n\n      this._connections.add(pipe)\n\n      pipe.on('close', () => {\n        this._connections.delete(pipe)\n        this._closeMaybe()\n      })\n\n      this.emit('connection', pipe)\n    } catch (err) {\n      pipe.destroy()\n\n      throw err\n    }\n  }\n\n  _onclose() {\n    const err = this._error\n\n    this._state &= ~constants.state.BINDING\n    this._error = null\n    this._handle = null\n\n    if (err) this.emit('error', err)\n    else this.emit('close')\n  }\n}\n\nexports.constants = constants\nexports.errors = errors\n\nexports.createConnection = function createConnection(path, opts, onconnect) {\n  if (typeof opts === 'function') {\n    onconnect = opts\n    opts = {}\n  }\n\n  if (typeof path === 'object' && path !== null) {\n    opts = path || {}\n    path = opts.path\n  }\n\n  return new exports.Pipe(opts).connect(path, opts, onconnect)\n}\n\nexports.createServer = function createServer(opts, onconnection) {\n  return new exports.Server(opts, onconnection)\n}\n\nconst empty = Buffer.alloc(0)\n\nfunction noop() {}\nmodule.exports = {\n  state: {\n    CONNECTING: 0x1,\n    CONNECTED: 0x2,\n    BINDING: 0x4,\n    BOUND: 0x8,\n    READING: 0x10,\n    CLOSING: 0x20,\n    READABLE: 0x40,\n    WRITABLE: 0x80\n  }\n}\nmodule.exports = class PipeError extends Error {\n  constructor(msg, code, fn = PipeError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'PipeError'\n  }\n\n  static PIPE_ALREADY_CONNECTED(msg) {\n    return new PipeError(\n      msg,\n      'PIPE_ALREADY_CONNECTED',\n      PipeError.PIPE_ALREADY_CONNECTED\n    )\n  }\n\n  static SERVER_ALREADY_LISTENING(msg) {\n    return new PipeError(\n      msg,\n      'SERVER_ALREADY_LISTENING',\n      PipeError.SERVER_ALREADY_LISTENING\n    )\n  }\n\n  static SERVER_IS_CLOSED(msg) {\n    return new PipeError(msg, 'SERVER_IS_CLOSED', PipeError.SERVER_IS_CLOSED)\n  }\n}\n{\n  \"name\": \"bare-pipe\",\n  \"version\": \"4.0.4\",\n  \"description\": \"Native I/O pipes for JavaScript\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./constants\": {\n      \"types\": \"./lib/constants.d.ts\",\n      \"default\": \"./lib/constants.js\"\n    },\n    \"./errors\": {\n      \"types\": \"./lib/errors.d.ts\",\n      \"default\": \"./lib/errors.js\"\n    }\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-pipe.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-pipe/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-pipe#readme\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.0.0\",\n    \"bare-stream\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"bare-path\": \"^3.0.0\",\n    \"brittle\": \"^3.2.1\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nconst stream = require('streamx')\n\nconst defaultEncoding = 'utf8'\n\nmodule.exports = exports = stream.Stream\n\nexports.pipeline = stream.pipeline\n\nexports.isStream = stream.isStream\nexports.isEnded = stream.isEnded\nexports.isFinished = stream.isFinished\nexports.isDisturbed = stream.isDisturbed\n\nexports.getStreamError = stream.getStreamError\n\nexports.Stream = exports\n\nexports.Readable = class Readable extends stream.Readable {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      map: null,\n      mapReadable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._read !== stream.Readable.prototype._read) {\n      this._read = read.bind(this, this._read)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n}\n\nexports.Writable = class Writable extends stream.Writable {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthWritable,\n      map: null,\n      mapWritable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._write !== stream.Writable.prototype._write) {\n      this._write = write.bind(this, this._write)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.Duplex = class Duplex extends stream.Duplex {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      byteLengthWritable,\n      map: null,\n      mapReadable: null,\n      mapWritable: null\n    })\n\n    if (this._construct) this._open = this._construct\n\n    if (this._read !== stream.Readable.prototype._read) {\n      this._read = read.bind(this, this._read)\n    }\n\n    if (this._write !== stream.Duplex.prototype._write) {\n      this._write = write.bind(this, this._write)\n    }\n\n    if (this._destroy !== stream.Stream.prototype._destroy) {\n      this._destroy = destroy.bind(this, this._destroy)\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.Transform = class Transform extends stream.Transform {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      byteLength: null,\n      byteLengthReadable: null,\n      byteLengthWritable,\n      map: null,\n      mapReadable: null,\n      mapWritable: null\n    })\n\n    if (this._transform !== stream.Transform.prototype._transform) {\n      this._transform = transform.bind(this, this._transform)\n    } else {\n      this._transform = passthrough\n    }\n  }\n\n  push(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    return super.push(chunk)\n  }\n\n  unshift(chunk, encoding) {\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding || defaultEncoding)\n    }\n\n    super.unshift(chunk)\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result = super.write({ chunk, encoding })\n\n    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)\n\n    return result\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n\n    if (typeof chunk === 'string') {\n      encoding = encoding || defaultEncoding\n      chunk = Buffer.from(chunk, encoding)\n    } else {\n      encoding = 'buffer'\n    }\n\n    const result =\n      chunk !== undefined && chunk !== null\n        ? super.end({ chunk, encoding })\n        : super.end()\n\n    if (cb) this.once('end', () => cb(null))\n\n    return result\n  }\n}\n\nexports.PassThrough = class PassThrough extends exports.Transform {}\n\nexports.finished = function finished(stream, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  if (!opts) opts = {}\n\n  const { cleanup = false } = opts\n\n  const done = () => {\n    cb(exports.getStreamError(stream, { all: true }))\n\n    if (cleanup) detach()\n  }\n\n  const detach = () => {\n    stream.off('close', done)\n    stream.off('error', noop)\n  }\n\n  if (stream.destroyed) {\n    done()\n  } else {\n    stream.on('close', done)\n    stream.on('error', noop)\n  }\n\n  return detach\n}\n\nfunction read(read, cb) {\n  read.call(this, 65536)\n\n  cb(null)\n}\n\nfunction write(write, data, cb) {\n  write.call(this, data.chunk, data.encoding, cb)\n}\n\nfunction transform(transform, data, cb) {\n  transform.call(this, data.chunk, data.encoding, cb)\n}\n\nfunction destroy(destroy, cb) {\n  destroy.call(this, exports.getStreamError(this), cb)\n}\n\nfunction passthrough(data, cb) {\n  cb(null, data.chunk)\n}\n\nfunction byteLengthWritable(data) {\n  return data.chunk.byteLength\n}\n\nfunction noop() {}\n{\n  \"name\": \"bare-stream\",\n  \"version\": \"2.6.5\",\n  \"description\": \"Streaming data for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./promises\": \"./promises.js\",\n    \"./web\": \"./web.js\",\n    \"./global\": \"./global.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"promises.js\",\n    \"web.js\",\n    \"global.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-stream.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-stream#readme\",\n  \"dependencies\": {\n    \"streamx\": \"^2.21.0\"\n  },\n  \"devDependencies\": {\n    \"bare-buffer\": \"^3.0.0\",\n    \"bare-events\": \"^2.5.4\",\n    \"brittle\": \"^3.5.2\",\n    \"prettier\": \"^3.3.3\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  },\n  \"peerDependencies\": {\n    \"bare-buffer\": \"*\",\n    \"bare-events\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bare-buffer\": {\n      \"optional\": true\n    },\n    \"bare-events\": {\n      \"optional\": true\n    }\n  }\n}\nconst { Readable, getStreamError, isStreamx, isDisturbed } = require('streamx')\n\n// https://streams.spec.whatwg.org/#readablestreamdefaultreader\nexports.ReadableStreamDefaultReader = class ReadableStreamDefaultReader {\n  constructor(stream) {\n    this._stream = stream._stream\n  }\n\n  read() {\n    const stream = this._stream\n\n    return new Promise((resolve, reject) => {\n      const err = getStreamError(stream)\n\n      if (err) return reject(err)\n\n      if (stream.destroyed) {\n        return resolve({ value: undefined, done: true })\n      }\n\n      const value = stream.read()\n\n      if (value !== null) {\n        return resolve({ value, done: false })\n      }\n\n      stream\n        .once('readable', onreadable)\n        .once('close', onclose)\n        .once('error', onerror)\n\n      function onreadable() {\n        const value = stream.read()\n\n        ondone(\n          null,\n          value === null\n            ? { value: undefined, done: true }\n            : { value, done: false }\n        )\n      }\n\n      function onclose() {\n        ondone(null, { value: undefined, done: true })\n      }\n\n      function onerror(err) {\n        ondone(err, null)\n      }\n\n      function ondone(err, value) {\n        stream\n          .off('readable', onreadable)\n          .off('close', onclose)\n          .off('error', onerror)\n\n        if (err) reject(err)\n        else resolve(value)\n      }\n    })\n  }\n\n  cancel(reason) {\n    if (this._stream.destroyed) return Promise.resolve()\n\n    return new Promise((resolve) =>\n      this._stream.once('close', resolve).destroy(reason)\n    )\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestreamdefaultcontroller\nexports.ReadableStreamDefaultController = class ReadableStreamDefaultController {\n  constructor(stream) {\n    this._stream = stream._stream\n  }\n\n  get desiredSize() {\n    return (\n      this._stream._readableState.highWaterMark -\n      this._stream._readableState.buffered\n    )\n  }\n\n  enqueue(data) {\n    this._stream.push(data)\n  }\n\n  close() {\n    this._stream.push(null)\n  }\n\n  error(err) {\n    this._stream.destroy(err)\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream\nexports.ReadableStream = class ReadableStream {\n  constructor(underlyingSource = {}, queuingStrategy) {\n    if (isStreamx(underlyingSource)) {\n      this._stream = underlyingSource\n    } else {\n      if (queuingStrategy === undefined) {\n        queuingStrategy = new exports.CountQueuingStrategy()\n      }\n\n      const { start, pull } = underlyingSource\n      const { highWaterMark = 1, size = defaultSize } = queuingStrategy\n\n      this._stream = new Readable({ highWaterMark, byteLength: size })\n\n      const controller = new exports.ReadableStreamDefaultController(this)\n\n      if (start) {\n        this._stream._open = open.bind(this, start.call(this, controller))\n      }\n\n      if (pull) {\n        this._stream._read = read.bind(this, pull.bind(this, controller))\n      }\n    }\n  }\n\n  getReader() {\n    return new exports.ReadableStreamDefaultReader(this)\n  }\n\n  cancel(reason) {\n    if (this._stream.destroyed) return Promise.resolve()\n\n    return new Promise((resolve) =>\n      this._stream.once('close', resolve).destroy(reason)\n    )\n  }\n\n  pipeTo(destination) {\n    return new Promise((resolve, reject) =>\n      this._stream.pipe(destination, (err) => {\n        err ? reject(err) : resolve()\n      })\n    )\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._stream[Symbol.asyncIterator]()\n  }\n\n  static from(iterable) {\n    return new ReadableStream(Readable.from(iterable))\n  }\n}\n\nasync function open(starting, cb) {\n  try {\n    await starting\n\n    cb(null)\n  } catch (err) {\n    cb(err)\n  }\n}\n\nasync function read(pull, cb) {\n  try {\n    await pull()\n\n    cb(null)\n  } catch (err) {\n    cb(err)\n  }\n}\n\nfunction defaultSize() {\n  return 1\n}\n\n// https://streams.spec.whatwg.org/#countqueuingstrategy\nexports.CountQueuingStrategy = class CountQueuingStrategy {\n  constructor(opts = {}) {\n    const { highWaterMark = 1 } = opts\n\n    this.highWaterMark = highWaterMark\n  }\n\n  size(chunk) {\n    return 1\n  }\n}\n\n// https://streams.spec.whatwg.org/#bytelengthqueuingstrategy\nexports.ByteLengthQueuingStrategy = class ByteLengthQueuingStrategy {\n  constructor(opts = {}) {\n    const { highWaterMark = 16384 } = opts\n\n    this.highWaterMark = highWaterMark\n  }\n\n  size(chunk) {\n    return chunk.byteLength\n  }\n}\n\n// https://streams.spec.whatwg.org/#is-readable-stream-disturbed\nexports.isReadableStreamDisturbed = function isReadableStreamDisturbed(stream) {\n  return isDisturbed(stream._stream)\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst EventEmitter = require('bare-events')\nconst { Duplex } = require('bare-stream')\nconst dns = require('bare-dns')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\nconst ip = require('./lib/ip')\n\nconst defaultReadBufferSize = 65536\n\nexports.Socket = class TCPSocket extends Duplex {\n  constructor(opts = {}) {\n    super({ eagerOpen: true })\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._allowHalfOpen = allowHalfOpen\n\n    this._remotePort = -1\n    this._remoteHost = null\n    this._remoteFamily = 0\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n    this._pendingFinal = null\n    this._pendingDestroy = null\n\n    this._timer = null\n    this._timeout = 0\n\n    this._buffer = Buffer.alloc(readBufferSize)\n\n    this._handle = binding.init(\n      this._buffer,\n      this,\n      noop,\n      this._onconnect,\n      this._onread,\n      this._onwrite,\n      this._onfinal,\n      this._onclose\n    )\n  }\n\n  get connecting() {\n    return (this._state & constants.state.CONNECTING) !== 0\n  }\n\n  get pending() {\n    return (this._state & constants.state.CONNECTED) === 0\n  }\n\n  get timeout() {\n    return this._timeout || undefined // For Node.js compatibility\n  }\n\n  connect(port, host = 'localhost', opts = {}, onconnect) {\n    if (\n      this._state & constants.state.CONNECTING ||\n      this._state & constants.state.CONNECTED\n    ) {\n      throw errors.SOCKET_ALREADY_CONNECTED('Socket is already connected')\n    }\n\n    this._state |= constants.state.CONNECTING\n\n    if (typeof host === 'function') {\n      onconnect = host\n      host = 'localhost'\n    } else if (typeof opts === 'function') {\n      onconnect = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n    }\n\n    if (!host) host = 'localhost'\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const { lookup = dns.lookup, hints } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        if (this._state & constants.state.CLOSING) return\n\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.CONNECTING\n\n        if (err) {\n          if (this._pendingOpen) this._continueOpen(err)\n          else this.destroy(err)\n          return\n        }\n\n        this.connect(port, address, { ...opts, family }, onconnect)\n      })\n\n      return this\n    }\n\n    family = type\n\n    try {\n      binding.connect(this._handle, port, host, family)\n\n      if (opts.keepAlive === true) {\n        this.setKeepAlive(opts.keepAlive, opts.keepAliveInitialDelay)\n      }\n\n      if (opts.noDelay === true) {\n        this.setNoDelay()\n      }\n\n      if (opts.timeout) {\n        this.setTimeout(opts.timeout)\n      }\n\n      this._remotePort = port\n      this._remoteHost = host\n      this._remoteFamily = family\n\n      if (onconnect) this.once('connect', onconnect)\n    } catch (err) {\n      queueMicrotask(() => {\n        if (this._pendingOpen) this._pendingOpen(err)\n        else this.destroy(err)\n      })\n    }\n\n    return this\n  }\n\n  setKeepAlive(enable = false, delay = 0) {\n    if (typeof enable === 'number') {\n      delay = enable\n      enable = false\n    }\n\n    delay = Math.floor(delay / 1000)\n\n    if (delay === 0) enable = false\n\n    binding.keepalive(this._handle, enable, delay)\n\n    return this\n  }\n\n  setNoDelay(enable = true) {\n    binding.nodelay(this._handle, enable)\n\n    return this\n  }\n\n  setTimeout(ms, ontimeout) {\n    if (ms === 0) {\n      clearTimeout(this._timer)\n      this._timer = null\n    } else {\n      if (ontimeout) this.once('timeout', ontimeout)\n\n      this._timer = setTimeout(() => this.emit('timeout'), ms)\n      this._timer.unref()\n    }\n\n    this._timeout = ms\n\n    return this\n  }\n\n  ref() {\n    binding.ref(this._handle)\n  }\n\n  unref() {\n    binding.unref(this._handle)\n  }\n\n  _open(cb) {\n    if (this._state & constants.state.CONNECTED) return cb(null)\n    this._pendingOpen = cb\n  }\n\n  _read() {\n    if ((this._state & constants.state.READING) === 0) {\n      this._state |= constants.state.READING\n      binding.resume(this._handle)\n    }\n  }\n\n  _writev(batch, cb) {\n    this._pendingWrite = [cb, batch]\n    binding.writev(\n      this._handle,\n      batch.map(({ chunk }) => chunk)\n    )\n  }\n\n  _final(cb) {\n    this._pendingFinal = cb\n    binding.end(this._handle)\n  }\n\n  _predestroy() {\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    binding.close(this._handle)\n  }\n\n  _destroy(err, cb) {\n    if (this._state & constants.state.CLOSING) return cb(err)\n    this._state |= constants.state.CLOSING\n    this._pendingDestroy = cb\n    binding.close(this._handle)\n  }\n\n  _continueOpen(err) {\n    if (this._pendingOpen === null) return\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(err)\n  }\n\n  _continueWrite(err) {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite[0]\n    this._pendingWrite = null\n    cb(err)\n  }\n\n  _continueFinal(err) {\n    if (this._pendingFinal === null) return\n    const cb = this._pendingFinal\n    this._pendingFinal = null\n    cb(err)\n  }\n\n  _continueDestroy() {\n    if (this._pendingDestroy === null) return\n    const cb = this._pendingDestroy\n    this._pendingDestroy = null\n    cb(null)\n  }\n\n  _onconnect(err) {\n    if (err) {\n      if (this._pendingOpen) this._continueOpen(err)\n      else this.destroy(err)\n      return\n    }\n\n    this._state |= constants.state.CONNECTED\n    this._state &= ~constants.state.CONNECTING\n    this._continueOpen()\n\n    this.emit('connect')\n  }\n\n  _onread(err, read) {\n    if (this._timer) this._timer.refresh()\n\n    if (err) {\n      this.destroy(err)\n      return\n    }\n\n    if (read === 0) {\n      this.push(null)\n      if (this._allowHalfOpen === false) this.end()\n      return\n    }\n\n    const copy = Buffer.allocUnsafe(read)\n    copy.set(this._buffer.subarray(0, read))\n\n    if (this.push(copy) === false && this.destroying === false) {\n      this._state &= ~constants.state.READING\n      binding.pause(this._handle)\n    }\n  }\n\n  _onwrite(err) {\n    if (this._timer) this._timer.refresh()\n\n    this._continueWrite(err)\n  }\n\n  _onfinal(err) {\n    this._continueFinal(err)\n  }\n\n  _onclose() {\n    clearTimeout(this._timer)\n\n    this._handle = null\n    this._continueDestroy()\n  }\n}\n\nexports.Server = class TCPServer extends EventEmitter {\n  constructor(opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =\n      opts\n\n    this._state = 0\n\n    this._readBufferSize = readBufferSize\n    this._allowHalfOpen = allowHalfOpen\n\n    this._keepAlive = opts.keepAlive\n    this._keepAliveDelay = opts.keepAliveInitialDelay\n    this._noDelay = opts.noDelay\n\n    this._port = -1\n    this._host = null\n    this._family = 0\n    this._connections = new Set()\n\n    this._error = null\n    this._handle = null\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening() {\n    return (this._state & constants.state.BOUND) !== 0\n  }\n\n  address() {\n    if ((this._state & constants.state.BOUND) === 0) {\n      return null\n    }\n\n    return {\n      address: this._host,\n      family: `IPv${this._family}`,\n      port: this._port\n    }\n  }\n\n  listen(port = 0, host = 'localhost', backlog = 511, opts = {}, onlistening) {\n    if (\n      this._state & constants.state.BINDING ||\n      this._state & constants.state.BOUND\n    ) {\n      throw errors.SERVER_ALREADY_LISTENING('Server is already listening')\n    }\n\n    if (this._state & constants.state.CLOSING) {\n      throw errors.SERVER_IS_CLOSED('Server is closed')\n    }\n\n    this._state |= constants.state.BINDING\n\n    if (typeof port === 'function') {\n      onlistening = port\n      port = 0\n    } else if (typeof host === 'function') {\n      onlistening = host\n      host = 'localhost'\n    } else if (typeof backlog === 'function') {\n      onlistening = backlog\n      backlog = 511\n    } else if (typeof opts === 'function') {\n      onlistening = opts\n      opts = {}\n    }\n\n    let family = 0\n\n    if (typeof port === 'object' && port !== null) {\n      opts = port || {}\n      port = opts.port || 0\n      host = opts.host || 'localhost'\n      family = opts.family || 0\n      backlog = opts.backlog || 511\n    }\n\n    if (!host) host = 'localhost'\n    if (!backlog) backlog = 511\n\n    const type = ip.isIP(host)\n\n    if (type === 0) {\n      const { lookup = dns.lookup, hints } = opts\n\n      lookup(host, { family, hints }, (err, address, family) => {\n        if (this._state & constants.state.CLOSING) return\n\n        this.emit('lookup', err, address, family, host)\n\n        this._state &= ~constants.state.BINDING\n\n        if (err) return this.emit('error', err)\n\n        this.listen(port, address, backlog, { ...opts, family }, onlistening)\n      })\n\n      return this\n    }\n\n    family = type\n\n    this._handle = binding.init(\n      empty,\n      this,\n      this._onconnection,\n      noop,\n      noop,\n      noop,\n      noop,\n      this._onclose\n    )\n\n    if (this._state & constants.state.UNREFED) binding.unref(this._handle)\n\n    try {\n      this._port = binding.bind(this._handle, port, host, backlog, family)\n      this._host = host\n      this._family = family\n      this._state |= constants.state.BOUND\n      this._state &= ~constants.state.BINDING\n\n      if (onlistening) this.once('listening', onlistening)\n\n      queueMicrotask(() => this.emit('listening'))\n    } catch (err) {\n      this._error = err\n\n      binding.close(this._handle)\n    }\n\n    return this\n  }\n\n  close(onclose) {\n    if (onclose) this.once('close', onclose)\n    if (this._state & constants.state.CLOSING) return\n    this._state |= constants.state.CLOSING\n    this._closeMaybe()\n  }\n\n  ref() {\n    this._state &= ~constants.state.UNREFED\n    if (this._handle !== null) binding.ref(this._handle)\n  }\n\n  unref() {\n    this._state |= constants.state.UNREFED\n    if (this._handle !== null) binding.unref(this._handle)\n  }\n\n  _closeMaybe() {\n    if (this._state & constants.state.CLOSING && this._connections.size === 0) {\n      if (this._handle !== null) binding.close(this._handle)\n      else queueMicrotask(() => this.emit('close'))\n    }\n  }\n\n  _onconnection(err) {\n    if (err) {\n      this.emit('error', err)\n      return\n    }\n\n    if (this._state & constants.state.CLOSING) return\n\n    const socket = new exports.Socket({\n      readBufferSize: this._readBufferSize,\n      allowHalfOpen: this._allowHalfOpen\n    })\n\n    try {\n      binding.accept(this._handle, socket._handle)\n\n      socket._state |= constants.state.CONNECTED\n\n      this._connections.add(socket)\n\n      if (this._keepAlive === true) {\n        socket.setKeepAlive(this._keepAlive, this._keepAliveDelay)\n      }\n\n      if (this._noDelay === true) {\n        socket.setNoDelay()\n      }\n\n      socket.on('close', () => {\n        this._connections.delete(socket)\n        this._closeMaybe()\n      })\n\n      this.emit('connection', socket)\n    } catch (err) {\n      socket.destroy()\n\n      throw err\n    }\n  }\n\n  _onclose() {\n    const err = this._error\n\n    this._state &= ~constants.state.BINDING\n    this._error = null\n    this._handle = null\n\n    if (err) this.emit('error', err)\n    else this.emit('close')\n  }\n}\n\nexports.constants = constants\nexports.errors = errors\n\nexports.isIP = ip.isIP\nexports.isIPv4 = ip.isIPv4\nexports.isIPv6 = ip.isIPv6\n\nexports.createConnection = function createConnection(\n  port,\n  host,\n  opts,\n  onconnect\n) {\n  if (typeof host === 'function') {\n    onconnect = host\n    host = 'localhost'\n  } else if (typeof opts === 'function') {\n    onconnect = opts\n    opts = {}\n  }\n\n  if (typeof port === 'object' && port !== null) {\n    opts = port || {}\n    port = opts.port || 0\n    host = opts.host || 'localhost'\n  }\n\n  return new exports.Socket(opts).connect(port, host, opts, onconnect)\n}\n\n// For Node.js compatibility\nexports.connect = exports.createConnection\n\nexports.createServer = function createServer(opts, onconnection) {\n  return new exports.Server(opts, onconnection)\n}\n\nconst empty = Buffer.alloc(0)\n\nfunction noop() {}\nmodule.exports = {\n  state: {\n    CONNECTING: 0x1,\n    CONNECTED: 0x2,\n    BINDING: 0x4,\n    BOUND: 0x8,\n    READING: 0x10,\n    CLOSING: 0x20,\n    UNREFED: 0x40\n  }\n}\nmodule.exports = class TCPError extends Error {\n  constructor(msg, code, fn = TCPError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'TCPError'\n  }\n\n  static SOCKET_ALREADY_CONNECTED(msg) {\n    return new TCPError(\n      msg,\n      'SOCKET_ALREADY_CONNECTED',\n      TCPError.SOCKET_ALREADY_CONNECTED\n    )\n  }\n\n  static SERVER_ALREADY_LISTENING(msg) {\n    return new TCPError(\n      msg,\n      'SERVER_ALREADY_LISTENING',\n      TCPError.SERVER_ALREADY_LISTENING\n    )\n  }\n\n  static SERVER_IS_CLOSED(msg) {\n    return new TCPError(msg, 'SERVER_IS_CLOSED', TCPError.SERVER_IS_CLOSED)\n  }\n\n  static INVALID_HOST(msg = 'Unrecognizable host format') {\n    return new TCPError(msg, 'INVALID_HOST', TCPError.INVALID_HOST)\n  }\n}\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`\nconst IPv4Pattern = new RegExp(`^${v4Str}$`)\n\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})'\nconst IPv6Pattern = new RegExp(\n  '^(' +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    ')(%[0-9a-zA-Z-.:]{1,})?$'\n)\n\nconst isIPv4 = (exports.isIPv4 = function isIPv4(host) {\n  return IPv4Pattern.test(host)\n})\n\nconst isIPv6 = (exports.isIPv6 = function isIPv6(host) {\n  return IPv6Pattern.test(host)\n})\n\nexports.isIP = function isIP(host) {\n  if (isIPv4(host)) return 4\n  if (isIPv6(host)) return 6\n  return 0\n}\n{\n  \"name\": \"bare-tcp\",\n  \"version\": \"2.0.3\",\n  \"description\": \"Native TCP sockets for JavaScript\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-tcp.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-tcp/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-tcp#readme\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"dependencies\": {\n    \"bare-dns\": \"^2.0.4\",\n    \"bare-events\": \"^2.5.4\",\n    \"bare-stream\": \"^2.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require.addon()\n/* global Bare */\nconst { Duplex } = require('bare-stream')\nconst binding = require('./binding')\nconst constants = require('./lib/constants')\nconst errors = require('./lib/errors')\n\nconst readBufferSize = 65536\n\nconst context = binding.context()\n\nexports.Socket = class TLSSocket extends Duplex {\n  static _buffer = Buffer.alloc(readBufferSize)\n\n  constructor(socket, opts = {}) {\n    const {\n      isServer = false,\n      cert = null,\n      key = null,\n      host = null,\n      eagerOpen = true,\n      allowHalfOpen = true\n    } = opts\n\n    super({ eagerOpen })\n\n    this._state = 0\n\n    this._socket = socket\n    this._key = key\n    this._cert = cert\n    this._allowHalfOpen = allowHalfOpen\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n\n    this._buffer = null\n\n    this._handle = binding.init(\n      context,\n      isServer,\n      cert,\n      key,\n      host,\n      this,\n      this._onread,\n      this._onwrite\n    )\n  }\n\n  get socket() {\n    return this._socket\n  }\n\n  get encrypted() {\n    return true\n  }\n\n  _onconnect() {\n    this._state |= constants.state.HANDSHAKE\n\n    this.emit('connect')\n\n    const cb = this._pendingOpen\n    this._pendingOpen = null\n    cb(null)\n  }\n\n  _ondata(data) {\n    if (this._buffer !== null) {\n      this._buffer = Buffer.concat([this._buffer, data])\n    } else {\n      this._buffer = data\n    }\n\n    while (this._buffer !== null) {\n      if (this._state & constants.state.HANDSHAKE) {\n        let read\n        try {\n          read = binding.read(this._handle, TLSSocket._buffer)\n        } catch (err) {\n          return this.destroy(errors.from(err))\n        }\n\n        if (read < 0) break\n\n        if (read === 0) {\n          this.push(null)\n          if (this._allowHalfOpen === false) this.end()\n          return\n        }\n\n        const copy = Buffer.allocUnsafe(read)\n        copy.set(TLSSocket._buffer.subarray(0, read))\n\n        this.push(copy)\n      } else {\n        try {\n          if (binding.handshake(this._handle)) this._onconnect()\n          else break\n        } catch (err) {\n          if (this._pendingOpen) this._pendingOpen(errors.from(err))\n          else this.destroy(errors.from(err))\n          return\n        }\n      }\n    }\n  }\n\n  _ondrain() {\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    if (cb) cb(null)\n  }\n\n  _onend() {\n    this.push(null)\n  }\n\n  _onclose() {\n    this.destroy()\n  }\n\n  _onread(data) {\n    let buffer = this._buffer\n    if (buffer === null) return 0\n\n    if (buffer.byteLength > data.byteLength) {\n      const rest = buffer.subarray(data.byteLength)\n      buffer = buffer.subarray(0, data.byteLength)\n      this._buffer = rest\n    } else {\n      this._buffer = null\n    }\n\n    data.set(buffer)\n\n    return buffer.byteLength\n  }\n\n  _onwrite(data) {\n    data = Buffer.from(data)\n\n    if (this._socket.write(data)) this._pendingWrite = null\n\n    return data.byteLength\n  }\n\n  _open(cb) {\n    this._pendingOpen = cb\n\n    this._socket\n      .on('data', this._ondata.bind(this))\n      .on('drain', this._ondrain.bind(this))\n      .on('end', this._onend.bind(this))\n      .on('close', this._onclose.bind(this))\n\n    try {\n      if (binding.handshake(this._handle)) this._onconnect()\n    } catch (err) {\n      this._pendingOpen = null\n\n      cb(errors.from(err))\n    }\n  }\n\n  _write(data, encoding, cb) {\n    this._pendingWrite = cb\n\n    try {\n      binding.write(this._handle, data)\n\n      if (this._pendingWrite !== null) return\n\n      cb(null)\n    } catch (err) {\n      this._pendingWrite = null\n\n      cb(errors.from(err))\n    }\n  }\n\n  _final(cb) {\n    try {\n      binding.shutdown(this._handle)\n\n      cb(null)\n    } catch (err) {\n      cb(err)\n    }\n\n    this._socket.end()\n  }\n\n  _predestroy() {\n    binding.destroy(this._handle)\n    this._handle = null\n  }\n\n  _destroy(err, cb) {\n    if (this._handle) {\n      binding.destroy(this._handle)\n      this._handle = null\n    }\n    cb(err)\n  }\n}\n\nexports.TLSSocket = exports.Socket // For Node.js compatibility\n\nexports.constants = constants\nexports.errors = errors\nmodule.exports = {\n  state: {\n    HANDSHAKE: 0x1\n  }\n}\nmodule.exports = class TLSError extends Error {\n  constructor(msg, code, fn = TLSError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'TLSError'\n  }\n\n  static from(err) {\n    return new TLSError(err.message, err.code, TLSError.from)\n  }\n}\n{\n  \"name\": \"bare-tls\",\n  \"version\": \"2.0.0\",\n  \"description\": \"Transport Layer Security (TLS) streams for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-tls.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-tls/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-tls#readme\",\n  \"engines\": {\n    \"bare\": \">=1.7.0\"\n  },\n  \"dependencies\": {\n    \"bare-stream\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^3.0.0\",\n    \"brittle\": \"^3.1.1\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require.addon()\nconst path = require('bare-path')\nconst binding = require('./binding')\nconst errors = require('./lib/errors')\n\nconst isWindows = Bare.platform === 'win32'\n\nmodule.exports = exports = class URL {\n  static {\n    binding.tag(this)\n  }\n\n  constructor(input, base, opts = {}) {\n    if (arguments.length === 0) throw errors.INVALID_URL()\n\n    input = `${input}`\n\n    if (base !== undefined) base = `${base}`\n\n    this._components = new Uint32Array(8)\n\n    this._parse(input, base, opts.throw !== false)\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-href\n\n  get href() {\n    return this._href\n  }\n\n  set href(value) {\n    this._update(value)\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-protocol\n\n  get protocol() {\n    return this._slice(0, this._components[0]) + ':'\n  }\n\n  set protocol(value) {\n    this._update(\n      this._replace(value.replace(/:+$/, ''), 0, this._components[0])\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-username\n\n  get username() {\n    return this._slice(this._components[0] + 3 /* :// */, this._components[1])\n  }\n\n  set username(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    if (this.username === '') value += '@'\n\n    this._update(\n      this._replace(\n        value,\n        this._components[0] + 3 /* :// */,\n        this._components[1]\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-password\n\n  get password() {\n    return this._href.slice(\n      this._components[1] + 1 /* : */,\n      this._components[2] - 1 /* @ */\n    )\n  }\n\n  set password(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    let start = this._components[1] + 1 /* : */\n    let end = this._components[2] - 1 /* @ */\n\n    if (this.password === '') {\n      value = ':' + value\n      start--\n    }\n\n    if (this.username === '') {\n      value += '@'\n      end++\n    }\n\n    this._update(this._replace(value, start, end))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-host\n\n  get host() {\n    return this._slice(this._components[2], this._components[5])\n  }\n\n  set host(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    this._update(\n      this._replace(\n        value,\n        this._components[2],\n        this._components[value.includes(':') ? 5 : 3]\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-hostname\n\n  get hostname() {\n    return this._slice(this._components[2], this._components[3])\n  }\n\n  set hostname(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    this._update(this._replace(value, this._components[2], this._components[3]))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-port\n\n  get port() {\n    return this._slice(this._components[3] + 1 /* : */, this._components[5])\n  }\n\n  set port(value) {\n    if (cannotHaveCredentialsOrPort(this)) {\n      return\n    }\n\n    let start = this._components[3] + 1 /* : */\n\n    if (this.port === '') {\n      value = ':' + value\n      start--\n    }\n\n    this._update(this._replace(value, start, this._components[5]))\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-pathname\n\n  get pathname() {\n    return this._slice(this._components[5], this._components[6] - 1 /* ? */)\n  }\n\n  set pathname(value) {\n    if (hasOpaquePath(this)) {\n      return\n    }\n\n    if (value[0] !== '/' && value[0] !== '\\\\') {\n      value = '/' + value\n    }\n\n    this._update(\n      this._replace(value, this._components[5], this._components[6] - 1 /* ? */)\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-search\n\n  get search() {\n    return this._slice(\n      this._components[6] - 1 /* ? */,\n      this._components[7] - 1 /* # */\n    )\n  }\n\n  set search(value) {\n    if (value && value[0] !== '?') value = '?' + value\n\n    this._update(\n      this._replace(\n        value,\n        this._components[6] - 1 /* ? */,\n        this._components[7] - 1 /* # */\n      )\n    )\n  }\n\n  // https://url.spec.whatwg.org/#dom-url-hash\n\n  get hash() {\n    return this._slice(this._components[7] - 1 /* # */)\n  }\n\n  set hash(value) {\n    if (value && value[0] !== '#') value = '#' + value\n\n    this._update(this._replace(value, this._components[7] - 1 /* # */))\n  }\n\n  toString() {\n    return this._href\n  }\n\n  toJSON() {\n    return this._href\n  }\n\n  [Symbol.for('bare.inspect')]() {\n    return {\n      __proto__: { constructor: URL },\n\n      href: this.href,\n      protocol: this.protocol,\n      username: this.username,\n      password: this.password,\n      host: this.host,\n      hostname: this.hostname,\n      port: this.port,\n      pathname: this.pathname,\n      search: this.search,\n      hash: this.hash\n    }\n  }\n\n  _slice(start, end = this._href.length) {\n    return this._href.slice(start, end)\n  }\n\n  _replace(replacement, start, end = this._href.length) {\n    return this._slice(0, start) + replacement + this._slice(end)\n  }\n\n  _parse(href, base, shouldThrow) {\n    try {\n      this._href = binding.parse(\n        String(href),\n        base ? String(base) : null,\n        this._components,\n        shouldThrow\n      )\n    } catch (err) {\n      if (err instanceof TypeError) throw err\n\n      throw errors.INVALID_URL()\n    }\n  }\n\n  _update(href) {\n    try {\n      this._parse(href, null, true)\n    } catch (err) {\n      if (err instanceof TypeError) throw err\n    }\n  }\n}\n\n// https://url.spec.whatwg.org/#url-opaque-path\nfunction hasOpaquePath(url) {\n  return url.pathname[0] !== '/'\n}\n\n// https://url.spec.whatwg.org/#cannot-have-a-username-password-port\nfunction cannotHaveCredentialsOrPort(url) {\n  return url.hostname === '' || url.protocol === 'file:'\n}\n\nconst URL = exports\n\nexports.URL = URL // For Node.js compatibility\n\nexports.errors = errors\n\nexports.isURL = function isURL(value) {\n  if (typeof value !== 'object' || value === null) return false\n\n  let constructor = value.constructor\n\n  while (typeof constructor === 'function') {\n    if (binding.isTagged(constructor)) return true\n\n    constructor = Reflect.getPrototypeOf(constructor)\n  }\n\n  return false\n}\n\nexports.parse = function parse(input, base) {\n  const url = new URL(input, base, { throw: false })\n  return url.href ? url : null\n}\n\nexports.canParse = function canParse(input, base) {\n  return binding.canParse(String(input), base ? String(base) : null)\n}\n\nexports.fileURLToPath = function fileURLToPath(url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n  }\n\n  if (url.protocol !== 'file:') {\n    throw errors.INVALID_URL_SCHEME('The URL must use the file: protocol')\n  }\n\n  if (isWindows) {\n    if (/%2f|%5c/i.test(url.pathname)) {\n      throw errors.INVALID_FILE_URL_PATH(\n        'The file: URL path must not include encoded \\\\ or / characters'\n      )\n    }\n  } else {\n    if (url.hostname) {\n      throw errors.INVALID_FILE_URL_HOST(\n        \"The file: URL host must be 'localhost' or empty\"\n      )\n    }\n\n    if (/%2f/i.test(url.pathname)) {\n      throw errors.INVALID_FILE_URL_PATH(\n        'The file: URL path must not include encoded / characters'\n      )\n    }\n  }\n\n  const pathname = path.normalize(decodeURIComponent(url.pathname))\n\n  if (isWindows) {\n    if (url.hostname) return '\\\\\\\\' + url.hostname + pathname\n\n    const letter = pathname.charCodeAt(1) | 0x20\n\n    if (\n      letter < 0x61 /* a */ ||\n      letter > 0x7a /* z */ ||\n      pathname.charCodeAt(2) !== 0x3a /* : */\n    ) {\n      throw errors.INVALID_FILE_URL_PATH('The file: URL path must be absolute')\n    }\n\n    return pathname.slice(1)\n  }\n\n  return pathname\n}\n\nexports.pathToFileURL = function pathToFileURL(pathname) {\n  let resolved = path.resolve(pathname)\n\n  if (pathname[pathname.length - 1] === '/') {\n    resolved += '/'\n  } else if (isWindows && pathname[pathname.length - 1] === '\\\\') {\n    resolved += '\\\\'\n  }\n\n  resolved = resolved\n    .replaceAll('%', '%25') // Must be first\n    .replaceAll('#', '%23')\n    .replaceAll('?', '%3f')\n    .replaceAll('\\n', '%0a')\n    .replaceAll('\\r', '%0d')\n    .replaceAll('\\t', '%09')\n\n  if (!isWindows) {\n    resolved = resolved.replaceAll('\\\\', '%5c')\n  }\n\n  return new URL('file:' + resolved)\n}\nmodule.exports = class URLError extends Error {\n  constructor(msg, code, fn = URLError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'URLError'\n  }\n\n  static INVALID_URL(msg = 'Invalid URL') {\n    return new URLError(msg, 'INVALID_URL', URLError.INVALID_URL)\n  }\n\n  static INVALID_URL_SCHEME(msg = 'Invalid URL') {\n    return new URLError(msg, 'INVALID_URL_SCHEME', URLError.INVALID_URL_SCHEME)\n  }\n\n  static INVALID_FILE_URL_HOST(msg = 'Invalid file: URL host') {\n    return new URLError(\n      msg,\n      'INVALID_FILE_URL_HOST',\n      URLError.INVALID_FILE_URL_HOST\n    )\n  }\n\n  static INVALID_FILE_URL_PATH(msg = 'Invalid file: URL path') {\n    return new URLError(\n      msg,\n      'INVALID_FILE_URL_PATH',\n      URLError.INVALID_FILE_URL_PATH\n    )\n  }\n}\n{\n  \"name\": \"bare-url\",\n  \"version\": \"2.1.3\",\n  \"description\": \"WHATWG URL implementation for JavaScript\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./global\": {\n      \"types\": \"./global.d.ts\",\n      \"default\": \"./global.js\"\n    }\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"global.js\",\n    \"global.d.ts\",\n    \"binding.c\",\n    \"binding.js\",\n    \"CMakeLists.txt\",\n    \"lib\",\n    \"prebuilds\"\n  ],\n  \"addon\": true,\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-url.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-url/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-url\",\n  \"dependencies\": {\n    \"bare-path\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"cmake-bare\": \"^1.1.6\",\n    \"cmake-fetch\": \"^1.0.0\",\n    \"prettier\": \"^3.3.3\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nexports.Server = require('./lib/server')\nexports.Socket = require('./lib/socket')\nconst EOL = (exports.EOL = '\\r\\n')\n\nexports.EOF = EOL.repeat(2)\n\nexports.GUID = Buffer.from('258EAFA5-E914-47DA-95CA-C5AB0DC85B11')\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-11.8\nexports.opcode = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xa\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-7.4.1\nexports.status = {\n  PROTOCOL_ERROR: 1002,\n  MESSAGE_TOO_LARGE: 1009\n}\nconst { status } = require('./constants')\n\nmodule.exports = class WebSocketError extends Error {\n  constructor(msg, code, status, fn = WebSocketError, cause) {\n    super(`${code}: ${msg}`, { cause })\n    this.code = code\n    this.status = status\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'WebSocketError'\n  }\n\n  static NETWORK_ERROR(msg, cause) {\n    return new WebSocketError(\n      msg,\n      'NETWORK_ERROR',\n      0,\n      WebSocketError.NETWORK_ERROR,\n      cause\n    )\n  }\n\n  static NOT_CONNECTED(msg = 'Socket is not connected') {\n    return new WebSocketError(\n      msg,\n      'NOT_CONNECTED',\n      0,\n      WebSocketError.NOT_CONNECTED\n    )\n  }\n\n  static UNEXPECTED_RSV1(msg = 'RSV1 must be unset') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_RSV1',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_RSV1\n    )\n  }\n\n  static UNEXPECTED_RSV2(msg = 'RSV2 must be unset') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_RSV2',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_RSV2\n    )\n  }\n\n  static UNEXPECTED_RSV3(msg = 'RSV3 must be unset') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_RSV3',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_RSV3\n    )\n  }\n\n  static EXPECTED_MASK(msg = 'MASK must be set') {\n    return new WebSocketError(\n      msg,\n      'EXPECTED_MASK',\n      status.PROTOCOL_ERROR,\n      WebSocketError.EXPECTED_MASK\n    )\n  }\n\n  static UNEXPECTED_MASK(msg = 'MASK must be unset') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_MASK',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_MASK\n    )\n  }\n\n  static EXPECTED_CONTINUATION(msg = 'Expected a continuation frame') {\n    return new WebSocketError(\n      msg,\n      'EXPECTED_CONTINUATION',\n      status.PROTOCOL_ERROR,\n      WebSocketError.EXPECTED_CONTINUATION\n    )\n  }\n\n  static UNEXPECTED_CONTINUATION(msg = 'Unexpected continuation frame') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_CONTINUATION',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_CONTINUATION\n    )\n  }\n\n  static UNEXPECTED_CONTROL(msg = 'Unexpected control frame') {\n    return new WebSocketError(\n      msg,\n      'UNEXPECTED_CONTROL',\n      status.PROTOCOL_ERROR,\n      WebSocketError.UNEXPECTED_CONTROL\n    )\n  }\n\n  static INVALID_ENCODING(msg = 'Invalid encoding') {\n    return new WebSocketError(\n      msg,\n      'INVALID_ENCODING',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_ENCODING\n    )\n  }\n\n  static INVALID_UPGRADE_HEADER(msg = 'Invalid Upgrade header') {\n    return new WebSocketError(\n      msg,\n      'INVALID_UPGRADE_HEADER',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_UPGRADE_HEADER\n    )\n  }\n\n  static INVALID_VERSION_HEADER(msg = 'Invalid Sec-WebSocket-Version header') {\n    return new WebSocketError(\n      msg,\n      'INVALID_VERSION_HEADER',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_VERSION_HEADER\n    )\n  }\n\n  static INVALID_KEY_HEADER(msg = 'Invalid Sec-WebSocket-Key header') {\n    return new WebSocketError(\n      msg,\n      'INVALID_KEY_HEADER',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_KEY_HEADER\n    )\n  }\n\n  static INVALID_ACCEPT_HEADER(msg = 'Invalid Sec-WebSocket-Accept header') {\n    return new WebSocketError(\n      msg,\n      'INVALID_ACCEPT_HEADER',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_ACCEPT_HEADER\n    )\n  }\n\n  static INVALID_OPCODE(msg = 'Invalid opcode') {\n    return new WebSocketError(\n      msg,\n      'INVALID_OPCODE',\n      status.PROTOCOL_ERROR,\n      WebSocketError.INVALID_OPCODE\n    )\n  }\n\n  static INVALID_PAYLOAD_LENGTH(msg = 'Invalid payload length') {\n    return new WebSocketError(\n      msg,\n      'INVALID_PAYLOAD_LENGTH',\n      status.MESSAGE_TOO_LARGE,\n      WebSocketError.INVALID_PAYLOAD_LENGTH\n    )\n  }\n}\nconst crypto = require('bare-crypto')\nconst errors = require('./errors')\n\nconst EMPTY = Buffer.alloc(0)\n\nconst FIN = 0b10000000\nconst RSV1 = 0b01000000\nconst RSV2 = 0b00100000\nconst RSV3 = 0b00010000\nconst OPCODE = 0b00001111\nconst MASK = 0b10000000\nconst LENGTH = 0b01111111\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-5\nmodule.exports = exports = class Frame {\n  constructor(opcode, payload = EMPTY, opts = {}) {\n    if (payload && !Buffer.isBuffer(payload)) {\n      opts = payload\n      payload = EMPTY\n    }\n\n    const {\n      fin = true,\n      rsv1 = false,\n      rsv2 = false,\n      rsv3 = false,\n      mask = null\n    } = opts\n\n    this.fin = fin\n    this.rsv1 = rsv1\n    this.rsv2 = rsv2\n    this.rsv3 = rsv3\n    this.opcode = opcode\n    this.mask = mask\n    this.payload = payload\n  }\n\n  toBuffer() {\n    const state = { start: 0, end: 0, buffer: null }\n\n    Frame.preencode(state, this)\n\n    state.buffer = Buffer.allocUnsafe(state.end)\n\n    Frame.encode(state, this)\n\n    return state.buffer\n  }\n}\n\nconst Frame = exports\n\nexports.preencode = function preencode(state, f) {\n  let i = state.end\n\n  i++\n\n  const length = f.payload.length\n\n  if (length <= 0x7d) i++\n  else {\n    if (length <= 0xffff) i += 3\n    else i += 9\n  }\n\n  if (f.mask) i += 4\n\n  i += length\n\n  state.end = i\n}\n\nexports.encode = function encode(state, f) {\n  const b = state.buffer\n\n  let i = state.start\n\n  const v = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  b[i] = f.opcode & OPCODE\n\n  if (f.fin) b[i] |= FIN\n  if (f.rsv1) b[i] |= RSV1\n  if (f.rsv1) b[i] |= RSV2\n  if (f.rsv1) b[i] |= RSV3\n\n  i++\n\n  b[i] = f.mask ? MASK : 0\n\n  const length = f.payload.length\n\n  if (length <= 0x7d) b[i++] |= length\n  else {\n    if (length <= 0xffff) {\n      b[i++] |= 0x7e\n\n      v.setUint16(i, length, false)\n\n      i += 2\n    } else {\n      b[i++] |= 0x7f\n\n      const high = Math.floor(length / 0x100000000)\n\n      v.setUint16(i, high, false)\n\n      i += 4\n\n      const low = length & 0xffffffff\n\n      v.setUint16(i, low, false)\n\n      i += 4\n    }\n  }\n\n  if (f.mask) {\n    crypto.randomFill(f.mask, 0, 4)\n\n    b.set(f.mask, i)\n\n    i += 4\n\n    for (let j = 0; j < length; j++) {\n      b[i + j] = f.payload[j] ^ f.mask[j & 3]\n    }\n  } else {\n    b.set(f.payload, i)\n  }\n\n  i += length\n\n  state.start = i\n}\n\nexports.decode = function decode(state) {\n  const b = state.buffer\n\n  let i = state.start\n  let n = b.length\n\n  if (n < 2) return null\n\n  const view = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  const fin = !!(b[i] & FIN)\n\n  const rsv1 = !!(b[i] & RSV1)\n  const rsv2 = !!(b[i] & RSV2)\n  const rsv3 = !!(b[i] & RSV3)\n\n  const opcode = b[i] & OPCODE\n\n  i++\n  n--\n\n  const masked = !!(b[i] & MASK)\n\n  let length = b[i] & LENGTH\n\n  i++\n  n--\n\n  if (length === 0x7e) {\n    if (n < 2) return null\n\n    length = view.getUint16(i, false)\n\n    i += 2\n    n -= 2\n  } else if (length === 0x7f) {\n    if (n < 8) return null\n\n    const high = view.getUint32(i, false)\n\n    if (high >= 0x200000) throw errors.INVALID_PAYLOAD_LENGTH()\n\n    i += 4\n    n -= 4\n\n    const low = view.getUint32(i, false)\n\n    i += 4\n    n -= 4\n\n    length = high * 0x100000000 + low\n  }\n\n  let mask = null\n\n  if (masked) {\n    if (n < 4) return null\n\n    mask = b.subarray(i, i + 4)\n\n    i += 4\n    n -= 4\n  }\n\n  if (n < length) return null\n\n  const payload = b.subarray(i, i + length)\n\n  i += length\n  n -= length\n\n  if (mask) {\n    for (let i = 0; i < length; i++) {\n      payload[i] ^= mask[i & 3]\n    }\n  }\n\n  state.start = i\n\n  return new Frame(opcode, payload, { fin, rsv1, rsv2, rsv3, mask })\n}\nconst EventEmitter = require('bare-events')\nconst http = require('bare-http1')\nconst https = require('bare-https')\nconst crypto = require('bare-crypto')\nconst { GUID, EOL, EOF } = require('./constants')\nconst errors = require('./errors')\nconst WebSocket = require('./socket')\n\nconst EMPTY = Buffer.alloc(0)\n\nconst KEY = /^[+/0-9A-Za-z]{22}==$/\n\nmodule.exports = exports = class WebSocketServer extends EventEmitter {\n  constructor(opts = {}, onconnection) {\n    if (typeof opts === 'function') {\n      onconnection = opts\n      opts = {}\n    }\n\n    super()\n\n    const createServer = opts.secure ? https.createServer : http.createServer\n\n    const {\n      server = createServer(opts, this._onrequest.bind(this)).listen(\n        opts,\n        this._onlistening.bind(this)\n      )\n    } = opts\n\n    this._server = server\n\n    this._server.on('upgrade', this._onupgrade.bind(this))\n\n    if (onconnection) this.on('connection', onconnection)\n  }\n\n  get listening() {\n    return this._server.listening\n  }\n\n  address() {\n    return this._server.address()\n  }\n\n  close(cb) {\n    return this._server.close(cb)\n  }\n\n  ref() {\n    this._server.ref()\n  }\n\n  unref() {\n    this._server.unref()\n  }\n\n  _onlistening() {\n    this.emit('listening')\n  }\n\n  _onrequest(req, res) {\n    const body = http.constants.status[426]\n\n    res.writeHead(426, {\n      'Content-Type': 'text/plain',\n      'Content-Length': body.length\n    })\n\n    res.end(body)\n  }\n\n  _onupgrade(req, socket, head) {\n    handshake(req, socket, head, (err) => {\n      if (err) return socket.destroy(err)\n\n      this.emit('connection', new WebSocket({ socket, isServer: true }), req)\n    })\n  }\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-4.2\nconst handshake = (exports.handshake = function handshake(\n  req,\n  socket = req.socket,\n  head = EMPTY,\n  cb\n) {\n  if (typeof socket === 'function') {\n    cb = socket\n    socket = req.socket\n    head = EMPTY\n  } else if (typeof head === 'function') {\n    cb = head\n    head = EMPTY\n  }\n\n  if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n    return cb(errors.INVALID_UPGRADE_HEADER())\n  }\n\n  const version = +req.headers['sec-websocket-version']\n\n  if (version !== 8 && version !== 13) {\n    return cb(errors.INVALID_VERSION_HEADER())\n  }\n\n  const key = req.headers['sec-websocket-key']\n\n  if (!key || !KEY.test(key)) {\n    return cb(errors.INVALID_KEY_HEADER())\n  }\n\n  const digest = crypto\n    .createHash('sha1')\n    .update(key)\n    .update(GUID)\n    .digest('base64')\n\n  socket.write(\n    'HTTP/1.1 101 Web Socket Protocol Handshake' +\n      EOL +\n      'Upgrade: WebSocket' +\n      EOL +\n      'Connection: Upgrade' +\n      EOL +\n      `Sec-WebSocket-Accept: ${digest}` +\n      EOF\n  )\n\n  if (head.byteLength) socket.unshift(head)\n\n  cb(null)\n})\nconst { Duplex } = require('bare-stream')\nconst http = require('bare-http1')\nconst https = require('bare-https')\nconst crypto = require('bare-crypto')\nconst { GUID, opcode } = require('./constants')\nconst errors = require('./errors')\nconst Frame = require('./frame')\n\nconst CLOSE = new Frame(opcode.CLOSE).toBuffer()\n\nmodule.exports = exports = class WebSocket extends Duplex {\n  constructor(url, opts = {}) {\n    if (typeof url === 'string') url = new URL(url)\n\n    if (isURL(url)) {\n      opts = opts ? { ...opts } : {}\n\n      opts.host = url.hostname\n      opts.path = url.pathname + url.search\n      opts.port = url.port ? parseInt(url.port, 10) : defaultPort(url)\n      opts.secure = url.protocol === 'https:' || url.protocol === 'wss:'\n    } else {\n      opts = url ? { ...url } : {}\n\n      // For Node.js compatibility\n      opts.host = opts.hostname || opts.host\n      opts.port =\n        typeof opts.port === 'string' ? parseInt(opts.port, 10) : opts.port\n    }\n\n    const { isServer = false, socket = null } = opts\n\n    super({ eagerOpen: true })\n\n    this._socket = null\n    this._isServer = isServer\n    this._mask = isServer ? null : Buffer.allocUnsafe(4)\n    this._fragments = []\n\n    this._pendingOpen = null\n    this._pendingWrite = null\n\n    this._buffer = null\n\n    if (socket !== null) this._attach(socket)\n    else this._connect(opts)\n  }\n\n  ping(data) {\n    if (this._socket === null) throw errors.NOT_CONNECTED()\n\n    if (typeof data === 'string') data = Buffer.from(data)\n\n    this._socket.write(\n      new Frame(opcode.PING, data, { mask: this._mask }).toBuffer()\n    )\n  }\n\n  pong(data) {\n    if (this._socket === null) throw errors.NOT_CONNECTED()\n\n    if (typeof data === 'string') data = Buffer.from(data)\n\n    this._socket.write(\n      new Frame(opcode.PONG, data, { mask: this._mask }).toBuffer()\n    )\n  }\n\n  _attach(socket) {\n    this._socket = socket\n\n    this._socket\n      .on('error', this._onerror.bind(this))\n      .on('close', this._onclose.bind(this))\n      .on('data', this._ondata.bind(this))\n      .on('drain', this._ondrain.bind(this))\n  }\n\n  _connect(opts) {\n    const request = opts.secure ? https.request : http.request\n\n    const req = request(opts)\n\n    handshake(req, (err) => {\n      const cb = this._pendingOpen\n      this._pendingOpen = null\n\n      if (err) req.socket.destroy()\n      else this._attach(req.socket)\n\n      cb(err)\n    })\n  }\n\n  _onerror(err) {\n    this.destroy(err)\n  }\n\n  _onclose() {\n    this.destroy()\n  }\n\n  _ondata(data) {\n    if (this._buffer === null) this._buffer = data\n    else this._buffer = Buffer.concat([this._buffer, data])\n\n    while (this._buffer !== null) {\n      const state = { start: 0, end: this._buffer.length, buffer: this._buffer }\n\n      let frame\n      try {\n        frame = Frame.decode(state)\n      } catch (err) {\n        return this.destroy(err)\n      }\n\n      if (frame === null) return\n\n      this._buffer =\n        state.start === state.end ? null : this._buffer.subarray(state.start)\n\n      try {\n        this._onframe(frame)\n      } catch (err) {\n        return this.destroy(err)\n      }\n    }\n  }\n\n  _onframe(frame) {\n    if (frame.rsv1) throw errors.UNEXPECTED_RSV1()\n\n    if (frame.rsv2) throw errors.UNEXPECTED_RSV2()\n\n    if (frame.rsv3) throw errors.UNEXPECTED_RSV3()\n\n    if (frame.payload.length > 0 && !frame.mask === this._isServer) {\n      throw this._isServer ? errors.EXPECTED_MASK() : errors.UNEXPECTED_MASK()\n    }\n\n    if (frame.fin === false) {\n      if (this._fragments.push(frame) === 1) {\n        // First frame\n        if (frame.opcode === opcode.CONTINUATION)\n          throw errors.UNEXPECTED_CONTINUATION()\n\n        if (frame.opcode >= opcode.CLOSE) throw errors.UNEXPECTED_CONTROL()\n\n        return\n      }\n\n      if (frame.opcode !== opcode.CONTINUATION)\n        throw errors.EXPECTED_CONTINUATION()\n\n      return\n    }\n\n    switch (frame.opcode) {\n      case opcode.CLOSE:\n        this.push(null)\n        this.end()\n        return\n\n      case opcode.PING:\n        this.pong(frame.payload)\n        this.emit('ping', frame.payload)\n        return\n\n      case opcode.PONG:\n        this.emit('pong', frame.payload)\n        return\n\n      case opcode.CONTINUATION: {\n        if (this._fragments.length === 0) throw errors.UNEXPECTED_CONTINUATION()\n\n        frame.opcode = this._fragments[0].opcode\n\n        const payloads = this._fragments.map((frame) => frame.payload)\n\n        payloads.push(frame.payload)\n\n        frame.payload = Buffer.concat(payloads)\n\n        this._fragments = []\n\n        break\n      }\n\n      default:\n        if (this._fragments.length > 0) throw errors.EXPECTED_CONTINUATION()\n    }\n\n    switch (frame.opcode) {\n      case opcode.TEXT:\n      case opcode.BINARY:\n        this.push(frame.payload)\n        break\n\n      default:\n        throw errors.INVALID_OPCODE()\n    }\n  }\n\n  _ondrain() {\n    if (this._pendingWrite === null) return\n    const cb = this._pendingWrite\n    this._pendingWrite = null\n    cb(null)\n  }\n\n  _open(cb) {\n    if (this._socket === null) this._pendingOpen = cb\n    else cb(null)\n  }\n\n  _write(data, encoding, cb) {\n    if (encoding !== 'buffer' && encoding !== 'utf8') {\n      return cb(errors.INVALID_ENCODING())\n    }\n\n    const frame = new Frame(\n      encoding === 'buffer' ? opcode.BINARY : opcode.TEXT,\n      data,\n      { mask: this._mask }\n    )\n\n    if (this._socket.write(frame.toBuffer())) cb(null)\n    else this._pendingWrite = cb\n  }\n\n  _final(cb) {\n    this._socket.end(CLOSE)\n    cb(null)\n  }\n\n  _predestroy() {\n    if (!this._socket) return\n    this._socket.destroy()\n  }\n}\n\n// https://datatracker.ietf.org/doc/html/rfc6455#section-4.1\nconst handshake = (exports.handshake = function handshake(req, cb) {\n  const key = crypto.randomBytes(16).toString('base64')\n\n  req.headers = {\n    ...req.headers,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    'Sec-WebSocket-Version': 13,\n    'Sec-WebSocket-Key': key\n  }\n\n  req.on('upgrade', (res, socket, head) => {\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      return cb(errors.INVALID_UPGRADE_HEADER())\n    }\n\n    const digest = crypto\n      .createHash('sha1')\n      .update(key)\n      .update(GUID)\n      .digest('base64')\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      return cb(errors.INVALID_ACCEPT_HEADER())\n    }\n\n    if (head.byteLength) socket.unshift(head)\n\n    cb(null)\n  })\n\n  req.on('error', (err) => {\n    cb(errors.NETWORK_ERROR('Network error', err))\n  })\n\n  req.end()\n})\n\n// https://url.spec.whatwg.org/#default-port\nfunction defaultPort(url) {\n  switch (url.protocol) {\n    case 'ftp:':\n      return 21\n    case 'http:':\n    case 'ws:':\n      return 80\n    case 'https:':\n    case 'wss:':\n      return 443\n  }\n\n  return null\n}\n\n// https://url.spec.whatwg.org/#api\nfunction isURL(url) {\n  return (\n    url !== null &&\n    typeof url === 'object' &&\n    typeof url.protocol === 'string' &&\n    typeof url.hostname === 'string' &&\n    typeof url.pathname === 'string' &&\n    typeof url.search === 'string'\n  )\n}\n{\n  \"name\": \"bare-ws\",\n  \"version\": \"2.0.1\",\n  \"description\": \"WebSocket library for JavaScript\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package\": \"./package.json\",\n    \"./constants\": \"./lib/constants.js\",\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check && bare test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-ws.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-ws/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-ws#readme\",\n  \"dependencies\": {\n    \"bare-crypto\": \"^1.2.0\",\n    \"bare-events\": \"^2.3.1\",\n    \"bare-http1\": \"^4.0.0\",\n    \"bare-https\": \"^2.0.0\",\n    \"bare-stream\": \"^2.1.2\"\n  },\n  \"devDependencies\": {\n    \"bare-fs\": \"^4.0.0\",\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-config-standard\": \"^7.0.0\"\n  }\n}\nmodule.exports = require('bare-crypto')\n{\n  \"name\": \"bare-node-crypto\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Bare compatibility wrapper for the Node.js builtin `crypto` module\",\n  \"exports\": {\n    \".\": \"./index.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-node.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-node/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-node#readme\",\n  \"dependencies\": {\n    \"bare-crypto\": \"*\"\n  }\n}\nmodule.exports = require('bare-events')\n{\n  \"name\": \"bare-node-events\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Bare compatibility wrapper for the Node.js builtin `events` module\",\n  \"exports\": {\n    \".\": \"./index.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-node.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-node/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-node#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"*\"\n  }\n}\nmodule.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\nconst FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n{\n  \"name\": \"fast-fifo\",\n  \"version\": \"1.3.2\",\n  \"description\": \"A fast fifo implementation similar to the one powering nextTick in Node.js core\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"./index.js\",\n    \"./fixed-size.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\",\n    \"brittle\": \"^3.3.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/fast-fifo.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/fast-fifo/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/fast-fifo\"\n}\nconst { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueMicrotask(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n{\n  \"name\": \"streamx\",\n  \"version\": \"2.22.0\",\n  \"description\": \"An iteration of the Node.js core streams with a series of improvements\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"fast-fifo\": \"^1.3.2\",\n    \"text-decoder\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"brittle\": \"^3.1.1\",\n    \"end-of-stream\": \"^1.4.4\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"optionalDependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/streamx.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/streamx/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/streamx\"\n}\nconst PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\nconst b4a = require('b4a')\n\nmodule.exports = class PassThroughDecoder {\n  constructor (encoding) {\n    this.encoding = encoding\n  }\n\n  get remaining () {\n    return 0\n  }\n\n  decode (tail) {\n    return b4a.toString(tail, this.encoding)\n  }\n\n  flush () {\n    return ''\n  }\n}\nconst b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  get remaining () {\n    return this.bytesSeen\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else {\n          this.bytesSeen = 1\n\n          if (byte >= 0xc2 && byte <= 0xdf) {\n            this.bytesNeeded = 2\n            this.codePoint = byte & 0x1f\n          } else if (byte >= 0xe0 && byte <= 0xef) {\n            if (byte === 0xe0) this.lowerBoundary = 0xa0\n            else if (byte === 0xed) this.upperBoundary = 0x9f\n            this.bytesNeeded = 3\n            this.codePoint = byte & 0xf\n          } else if (byte >= 0xf0 && byte <= 0xf4) {\n            if (byte === 0xf0) this.lowerBoundary = 0x90\n            if (byte === 0xf4) this.upperBoundary = 0x8f\n            this.bytesNeeded = 4\n            this.codePoint = byte & 0x7\n          } else {\n            result += '\\ufffd'\n          }\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n{\n  \"name\": \"text-decoder\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Streaming text decoder that preserves multibyte Unicode characters\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"browser\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/browser-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/browser-decoder.js\"\n  },\n  \"react-native\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/pass-through-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/utf8-decoder.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/text-decoder.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/text-decoder/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/text-decoder#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = require('bare-url')\n{\n  \"name\": \"bare-node-url\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Bare compatibility wrapper for the Node.js builtin `url` module\",\n  \"exports\": {\n    \".\": \"./index.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-node.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-node/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-node#readme\",\n  \"dependencies\": {\n    \"bare-url\": \"*\"\n  }\n}\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;\nvar max_js_1 = require(\"./max.js\");\nObject.defineProperty(exports, \"MAX\", { enumerable: true, get: function () { return max_js_1.default; } });\nvar nil_js_1 = require(\"./nil.js\");\nObject.defineProperty(exports, \"NIL\", { enumerable: true, get: function () { return nil_js_1.default; } });\nvar parse_js_1 = require(\"./parse.js\");\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parse_js_1.default; } });\nvar stringify_js_1 = require(\"./stringify.js\");\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return stringify_js_1.default; } });\nvar v1_js_1 = require(\"./v1.js\");\nObject.defineProperty(exports, \"v1\", { enumerable: true, get: function () { return v1_js_1.default; } });\nvar v1ToV6_js_1 = require(\"./v1ToV6.js\");\nObject.defineProperty(exports, \"v1ToV6\", { enumerable: true, get: function () { return v1ToV6_js_1.default; } });\nvar v3_js_1 = require(\"./v3.js\");\nObject.defineProperty(exports, \"v3\", { enumerable: true, get: function () { return v3_js_1.default; } });\nvar v4_js_1 = require(\"./v4.js\");\nObject.defineProperty(exports, \"v4\", { enumerable: true, get: function () { return v4_js_1.default; } });\nvar v5_js_1 = require(\"./v5.js\");\nObject.defineProperty(exports, \"v5\", { enumerable: true, get: function () { return v5_js_1.default; } });\nvar v6_js_1 = require(\"./v6.js\");\nObject.defineProperty(exports, \"v6\", { enumerable: true, get: function () { return v6_js_1.default; } });\nvar v6ToV1_js_1 = require(\"./v6ToV1.js\");\nObject.defineProperty(exports, \"v6ToV1\", { enumerable: true, get: function () { return v6ToV1_js_1.default; } });\nvar v7_js_1 = require(\"./v7.js\");\nObject.defineProperty(exports, \"v7\", { enumerable: true, get: function () { return v7_js_1.default; } });\nvar validate_js_1 = require(\"./validate.js\");\nObject.defineProperty(exports, \"validate\", { enumerable: true, get: function () { return validate_js_1.default; } });\nvar version_js_1 = require(\"./version.js\");\nObject.defineProperty(exports, \"version\", { enumerable: true, get: function () { return version_js_1.default; } });\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nfunction md5(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return (0, crypto_1.createHash)('md5').update(bytes).digest();\n}\nexports.default = md5;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nexports.default = { randomUUID: crypto_1.randomUUID };\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = '00000000-0000-0000-0000-000000000000';\n{\"type\":\"commonjs\"}\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_js_1 = require(\"./validate.js\");\nfunction parse(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexports.default = parse;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        (0, crypto_1.randomFillSync)(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\nexports.default = rng;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return (0, crypto_1.createHash)('sha1').update(bytes).digest();\n}\nexports.default = sha1;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsafeStringify = void 0;\nconst validate_js_1 = require(\"./validate.js\");\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nexports.unsafeStringify = unsafeStringify;\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexports.default = stringify;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateV1State = void 0;\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nconst _state = {};\nfunction v1(options, buf, offset) {\n    let bytes;\n    const isV6 = options?._v6 ?? false;\n    if (options) {\n        const optionsKeys = Object.keys(options);\n        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {\n            options = undefined;\n        }\n    }\n    if (options) {\n        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV1State(_state, now, rnds);\n        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV1State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.nsecs ??= 0;\n    if (now === state.msecs) {\n        state.nsecs++;\n        if (state.nsecs >= 10000) {\n            state.node = undefined;\n            state.nsecs = 0;\n        }\n    }\n    else if (now > state.msecs) {\n        state.nsecs = 0;\n    }\n    else if (now < state.msecs) {\n        state.node = undefined;\n    }\n    if (!state.node) {\n        state.node = rnds.slice(10, 16);\n        state.node[0] |= 0x01;\n        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    }\n    state.msecs = now;\n    return state;\n}\nexports.updateV1State = updateV1State;\nfunction v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    nsecs ??= 0;\n    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    node ??= rnds.slice(10, 16);\n    msecs += 12219292800000;\n    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    buf[offset++] = (tl >>> 24) & 0xff;\n    buf[offset++] = (tl >>> 16) & 0xff;\n    buf[offset++] = (tl >>> 8) & 0xff;\n    buf[offset++] = tl & 0xff;\n    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;\n    buf[offset++] = (tmh >>> 8) & 0xff;\n    buf[offset++] = tmh & 0xff;\n    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;\n    buf[offset++] = (tmh >>> 16) & 0xff;\n    buf[offset++] = (clockseq >>> 8) | 0x80;\n    buf[offset++] = clockseq & 0xff;\n    for (let n = 0; n < 6; ++n) {\n        buf[offset++] = node[n];\n    }\n    return buf;\n}\nexports.default = v1;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v1ToV6(uuid) {\n    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v6Bytes = _v1ToV6(v1Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;\n}\nexports.default = v1ToV6;\nfunction _v1ToV6(v1Bytes) {\n    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = void 0;\nconst md5_js_1 = require(\"./md5.js\");\nconst v35_js_1 = require(\"./v35.js\");\nvar v35_js_2 = require(\"./v35.js\");\nObject.defineProperty(exports, \"DNS\", { enumerable: true, get: function () { return v35_js_2.DNS; } });\nObject.defineProperty(exports, \"URL\", { enumerable: true, get: function () { return v35_js_2.URL; } });\nfunction v3(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);\n}\nv3.DNS = v35_js_1.DNS;\nv3.URL = v35_js_1.URL;\nexports.default = v3;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = exports.stringToBytes = void 0;\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexports.stringToBytes = stringToBytes;\nexports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = (0, parse_js_1.default)(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports.default = v35;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst native_js_1 = require(\"./native.js\");\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v4(options, buf, offset) {\n    if (native_js_1.default.randomUUID && !buf && !options) {\n        return native_js_1.default.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(rnds);\n}\nexports.default = v4;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = void 0;\nconst sha1_js_1 = require(\"./sha1.js\");\nconst v35_js_1 = require(\"./v35.js\");\nvar v35_js_2 = require(\"./v35.js\");\nObject.defineProperty(exports, \"DNS\", { enumerable: true, get: function () { return v35_js_2.DNS; } });\nObject.defineProperty(exports, \"URL\", { enumerable: true, get: function () { return v35_js_2.URL; } });\nfunction v5(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);\n}\nv5.DNS = v35_js_1.DNS;\nv5.URL = v35_js_1.URL;\nexports.default = v5;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stringify_js_1 = require(\"./stringify.js\");\nconst v1_js_1 = require(\"./v1.js\");\nconst v1ToV6_js_1 = require(\"./v1ToV6.js\");\nfunction v6(options, buf, offset) {\n    options ??= {};\n    offset ??= 0;\n    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));\n    bytes = (0, v1ToV6_js_1.default)(bytes);\n    if (buf) {\n        for (let i = 0; i < 16; i++) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports.default = v6;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v6ToV1(uuid) {\n    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v1Bytes = _v6ToV1(v6Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;\n}\nexports.default = v6ToV1;\nfunction _v6ToV1(v6Bytes) {\n    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateV7State = void 0;\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nconst _state = {};\nfunction v7(options, buf, offset) {\n    let bytes;\n    if (options) {\n        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV7State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.seq ??= 0;\n    if (now > state.msecs) {\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        state.seq = (state.seq + 1) | 0;\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nexports.updateV7State = updateV7State;\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    buf[offset++] = (seq >>> 20) & 0xff;\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    buf[offset++] = (seq >>> 6) & 0xff;\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\nexports.default = v7;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst regex_js_1 = require(\"./regex.js\");\nfunction validate(uuid) {\n    return typeof uuid === 'string' && regex_js_1.default.test(uuid);\n}\nexports.default = validate;\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_js_1 = require(\"./validate.js\");\nfunction version(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    return parseInt(uuid.slice(14, 15), 16);\n}\nexports.default = version;\n{\n  \"name\": \"wdk-proxy\",\n  \"description\": \"wdk proxy\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"lint\": \"standard\",\n    \"lint:fix\": \"standard --fix\",\n    \"bundle-android\": \"bare-pack --format bundle.cjs examples/ipc-mobile/child.js -p android --linked --out ./android.bundle.cjs\",\n    \"bundle-ios\": \"bare-pack --format bundle.cjs examples/ipc-mobile/child.js -p ios --linked --out ./ios.bundle.cjs\"\n  },\n  \"author\": {\n    \"name\": \"prdn\",\n    \"email\": \"paolo@bitfinex.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"prdn\",\n      \"email\": \"paolo@bitfinex.com\"\n    }\n  ],\n  \"keywords\": [\n    \"tether\",\n    \"proxy\",\n    \"wdk\"\n  ],\n  \"license\": \"Apache-2.0\",\n  \"dependencies\": {\n    \"bare-crypto\": \"^1.4.0\",\n    \"bare-events\": \"^2.5.4\",\n    \"bare-fetch\": \"^2.2.0\",\n    \"bare-http1\": \"^4.0.2\",\n    \"bare-ipc\": \"^1.1.0\",\n    \"bare-net\": \"^2.0.1\",\n    \"bare-path\": \"^3.0.0\",\n    \"bare-process\": \"^4.1.2\",\n    \"bare-subprocess\": \"^5.0.2\",\n    \"bare-url\": \"^2.1.3\",\n    \"bare-ws\": \"^2.0.1\",\n    \"crypto\": \"npm:bare-node-crypto@^1.0.0\",\n    \"events\": \"npm:bare-node-events@^1.0.1\",\n    \"http\": \"npm:bare-node-http@^1.0.1\",\n    \"net\": \"npm:bare-node-net@^1.0.0\",\n    \"path\": \"npm:bare-node-path@^1.0.1\",\n    \"process\": \"npm:bare-node-process@^1.0.1\",\n    \"standard\": \"^17.1.2\",\n    \"url\": \"npm:bare-node-url@^1.0.1\",\n    \"uuid\": \"^11.1.0\"\n  },\n  \"devDependencies\": {\n    \"bare-pack\": \"^1.2.4\"\n  }\n}\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst EventEmitter = require('events')\n\nclass ProxyClient extends EventEmitter {\n  constructor (transport) {\n    super()\n    this.transport = transport\n    this.pendingRequests = new Map()\n    this.requestIdCounter = 0\n\n    this.transport.on('response', (msg) => {\n      const { id, error, result } = msg\n      const pending = this.pendingRequests.get(id)\n      if (pending) {\n        const { resolve, reject } = pending\n        if (error) {\n          reject(new Error(error))\n        } else {\n          resolve(result)\n        }\n        this.pendingRequests.delete(id)\n      }\n    });\n\n    // Forward log events.\n    ['log', 'debug', 'info', 'warn', 'error'].forEach(level => {\n      this.transport.on(level, (msg) => {\n        this.emit(level, msg.payload.message)\n      })\n    })\n\n    this.transport.on('event', (msg) => {\n      this.emit(msg.event, msg.data)\n    })\n  }\n\n  _generateId () {\n    return `${Date.now()}-${this.requestIdCounter++}`\n  }\n\n  _sendRequest (request) {\n    return new Promise((resolve, reject) => {\n      const id = this._generateId()\n      request.id = id\n      this.pendingRequests.set(id, { resolve, reject })\n      this.transport.send(request).catch(reject)\n    })\n  }\n\n  async _subscribe (event, once = false) {\n    const request = { type: 'subscribe', event, once }\n    return this._sendRequest(request)\n  }\n\n  async connect () {\n    const self = this\n    const createProxy = (path = []) => {\n      return new Proxy(() => {}, {\n        get (target, prop) {\n          if (prop === 'then' && path.length === 0) {\n            return undefined\n          }\n          if (prop === 'on') {\n            return async (event, callback) => {\n              await self._subscribe(event, false)\n              self.on(event, callback)\n            }\n          }\n          if (prop === 'once') {\n            return async (event, callback) => {\n              await self._subscribe(event, true)\n              self.once(event, callback)\n            }\n          }\n          return createProxy([...path, prop])\n        },\n        apply (target, thisArg, args) {\n          const method = path.join('.')\n          const request = {\n            type: 'request',\n            method,\n            args\n          }\n          return self._sendRequest(request)\n        }\n      })\n    }\n    return createProxy()\n  }\n\n  close () {\n    if (typeof this.transport.close === 'function') {\n      this.transport.close()\n    }\n  }\n}\n\nmodule.exports = ProxyClient\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass ProxyServer {\n  constructor (transport) {\n    this.transport = transport\n    this.handler = null\n    this._requestListener = null\n    this._subscribeListener = null\n    this._patchConsole()\n  }\n\n  _patchConsole () {\n    if (global.__wdkProxyConsolePatched) return\n    global.__wdkProxyConsolePatched = true\n\n    const methods = ['log', 'debug', 'info', 'warn', 'error']\n    methods.forEach(method => {\n      const original = console[method]\n      console[method] = (...args) => {\n        original.apply(console, args)\n        if (this.transport && typeof this.transport.send === 'function') {\n          this.transport.send({\n            type: method,\n            payload: { message: args.join(' ') }\n          })\n        }\n      }\n    })\n  }\n\n  exposeHandler (handler) {\n    if (this.handler && this.transport.removeListener) {\n      this.transport.removeListener('request', this._requestListener)\n      this.transport.removeListener('subscribe', this._subscribeListener)\n    }\n\n    this.handler = handler\n\n    this._requestListener = async (msg, respond) => {\n      const { method, args } = msg\n      const parts = method.split('.')\n      let target = this.handler\n      for (const part of parts) {\n        if (target == null) break\n        target = target[part]\n      }\n      if (typeof target !== 'function') {\n        return respond(new TypeError(`Method \"${method}\" not found`))\n      }\n      try {\n        const result = await target.apply(this.handler, args)\n        respond(null, result)\n      } catch (err) {\n        respond(err)\n      }\n    }\n\n    this._subscribeListener = (msg, respond) => {\n      const { event, once } = msg\n      if (!this.handler || typeof this.handler.on !== 'function') {\n        return respond(new Error('Handler does not support events'))\n      }\n\n      const listener = (data) => {\n        this.transport.send({ type: 'event', event, data })\n      }\n\n      if (once) {\n        this.handler.once(event, listener)\n      } else {\n        this.handler.on(event, listener)\n      }\n      respond(null, `subscribed to ${event}`)\n    }\n\n    this.transport.on('request', this._requestListener)\n    this.transport.on('subscribe', this._subscribeListener)\n  }\n\n  emitEvent (event, data) {\n    this.transport.send({ type: 'event', event, data })\n  }\n\n  start () {\n    if (typeof this.transport.start === 'function') {\n      this.transport.start()\n    }\n  }\n\n  close () {\n    if (typeof this.transport.close === 'function') {\n      this.transport.close()\n    }\n    if (this.transport.removeListener) {\n      if (this._requestListener) {\n        this.transport.removeListener('request', this._requestListener)\n      }\n      if (this._subscribeListener) {\n        this.transport.removeListener('subscribe', this._subscribeListener)\n      }\n    }\n  }\n}\n\nmodule.exports = ProxyServer\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nmodule.exports = {\n  ProxyClient: require('./ProxyClient'),\n  ProxyServer: require('./ProxyServer')\n}\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass BaseTransport {\n  constructor (opts = {}) {\n    this.opts = opts\n    this._listeners = {}\n  }\n\n  async start () {\n    throw new Error('start() not implemented')\n  }\n\n  async connect () {\n    throw new Error('connect() not implemented')\n  }\n\n  async send (message) {\n    throw new Error('send() not implemented')\n  }\n\n  on (event, callback) {\n    if (!this._listeners[event]) this._listeners[event] = []\n    this._listeners[event].push(callback)\n  }\n\n  _emit (event, ...args) {\n    if (this._listeners[event]) {\n      for (const cb of this._listeners[event]) {\n        cb(...args)\n      }\n    }\n  }\n\n  close () {\n    throw new Error('close() not implemented')\n  }\n}\n\nmodule.exports = BaseTransport\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst net = require('bare-net')\nconst BaseTransport = require('./BaseTransport')\n\nclass DesktopIPCTransport extends BaseTransport {\n  constructor ({ serverOptions, clientOptions } = {}) {\n    super()\n    this.serverOptions = serverOptions || null\n    this.clientOptions = clientOptions || null\n    this.isServer = !!serverOptions\n    this.socket = null\n    this.server = null\n    this.pendingMessages = []\n    this.DELIMITER = '||END_OF_MSG||'\n    this._buffer = ''\n  }\n\n  async start () {\n    if (!this.isServer) {\n      throw new Error('start() should only be called on a server transport')\n    }\n    this.server = net.createServer((socket) => {\n      this.socket = socket\n      this._buffer = ''\n      socket.on('data', (data) => {\n        this._buffer += data.toString()\n        const parts = this._buffer.split(this.DELIMITER)\n        this._buffer = parts.pop()\n        for (const part of parts) {\n          if (!part.trim()) continue\n          let msg\n          try {\n            msg = JSON.parse(part)\n          } catch (err) {\n            continue\n          }\n          if (msg.type && this._listeners[msg.type]) {\n            if (msg.type === 'request' || msg.type === 'subscribe') {\n              this._emit(msg.type, msg, (err, result) => {\n                const response = {\n                  type: 'response',\n                  id: msg.id,\n                  error: err ? err.message : null,\n                  result\n                }\n                this.send(response)\n              })\n            } else {\n              this._emit(msg.type, msg)\n            }\n          }\n        }\n      })\n    })\n\n    return new Promise((resolve, reject) => {\n      this.server.listen(this.serverOptions, () => {\n        resolve()\n      })\n      this.server.on('error', reject)\n    })\n  }\n\n  async connect () {\n    if (this.isServer) {\n      throw new Error('connect() should only be called on a client transport')\n    }\n    if (!this.clientOptions || !this.clientOptions.port) {\n      throw new Error('clientOptions with a valid port must be provided for client mode')\n    }\n    this.socket = net.createConnection(\n      this.clientOptions.port,\n      this.clientOptions.host,\n      () => {\n        this.pendingMessages.forEach(data => this.socket.write(data))\n        this.pendingMessages = []\n        this._buffer = ''\n      }\n    )\n    this.socket.on('data', (data) => {\n      this._buffer += data.toString()\n      const parts = this._buffer.split(this.DELIMITER)\n      this._buffer = parts.pop()\n      for (const part of parts) {\n        if (!part.trim()) continue\n        let msg\n        try {\n          msg = JSON.parse(part)\n        } catch (err) {\n          continue\n        }\n        if (msg.type && this._listeners[msg.type]) {\n          this._emit(msg.type, msg)\n        }\n      }\n    })\n    return new Promise((resolve, reject) => {\n      this.socket.on('connect', resolve)\n      this.socket.on('error', reject)\n    })\n  }\n\n  async send (message) {\n    const data = JSON.stringify(message) + this.DELIMITER\n    if (this.socket && !this.socket.destroyed) {\n      this.socket.write(data)\n    } else {\n      this.pendingMessages.push(data)\n    }\n    return Promise.resolve()\n  }\n\n  close () {\n    if (this.socket) {\n      this.socket.end()\n    }\n    if (this.server) {\n      this.server.close()\n    }\n  }\n}\n\nmodule.exports = DesktopIPCTransport\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst http = require('bare-http1')\nconst BaseTransport = require('./BaseTransport')\nconst { v4: uuidv4 } = require('uuid')\nconst { URL } = require('url')\n\nclass HTTPTransport extends BaseTransport {\n  constructor ({ serverOptions, clientOptions } = {}) {\n    super()\n    this.serverOptions = serverOptions || null\n    this.clientOptions = clientOptions || null\n    this.isServer = !!serverOptions\n    this.eventClients = []\n    this.server = null\n    this.sseRequest = null\n  }\n\n  async start () {\n    if (!this.isServer) {\n      throw new Error('start() should only be called on a server transport')\n    }\n    this.server = http.createServer((req, res) => {\n      // POST /rpc endpoint for handling RPC requests.\n      if (req.method === 'POST' && req.url === '/rpc') {\n        let body = ''\n        req.on('data', chunk => { body += chunk })\n        req.on('end', () => {\n          let msg\n          try {\n            msg = JSON.parse(body)\n          } catch (err) {\n            res.statusCode = 400\n            res.end()\n            return\n          }\n          if (msg && msg.type && this._listeners[msg.type]) {\n            if (msg.type === 'request' || msg.type === 'subscribe') {\n              this._emit(msg.type, msg, (err, result) => {\n                const responseObj = {\n                  type: 'response',\n                  id: msg.id,\n                  error: err ? err.message : null,\n                  result\n                }\n                const responseBody = JSON.stringify(responseObj)\n                res.setHeader('Content-Type', 'application/json')\n                res.statusCode = 200\n                res.setHeader('Content-Length', Buffer.byteLength(responseBody))\n                res.write(responseBody)\n                res.end()\n              })\n            } else {\n              this._emit(msg.type, msg)\n              res.statusCode = 200\n              res.end()\n            }\n          } else {\n            res.statusCode = 400\n            res.end()\n          }\n        })\n      }\n      // GET /events endpoint for Server Sent Events (SSE).\n      else if (req.method === 'GET' && req.url === '/events') {\n        res.statusCode = 200\n        res.setHeader('Content-Type', 'text/event-stream')\n        res.setHeader('Cache-Control', 'no-cache')\n        res.setHeader('Connection', 'keep-alive')\n        res.write('')\n\n        const clientId = uuidv4()\n        const newClient = { id: clientId, res }\n        this.eventClients.push(newClient)\n\n        req.on('close', () => {\n          this.eventClients = this.eventClients.filter(c => c.id !== clientId)\n        })\n      }\n      // For any other endpoints, respond with 404.\n      else {\n        res.statusCode = 404\n        res.end()\n      }\n    })\n\n    return new Promise((resolve, reject) => {\n      const port = this.serverOptions.port\n      this.server.listen(port, () => {\n        console.log(`HTTP server started on port ${port}`)\n        resolve()\n      })\n      this.server.on('error', reject)\n    })\n  }\n\n  async connect () {\n    if (this.isServer) {\n      throw new Error('connect() should only be called on a client transport')\n    }\n    if (!this.clientOptions || !this.clientOptions.url) {\n      throw new Error('clientOptions with a valid URL must be provided for client mode')\n    }\n    // create an SSE connection.\n    const parsedUrl = new URL(this.clientOptions.url)\n    const options = {\n      method: 'GET',\n      hostname: parsedUrl.hostname,\n      port: parsedUrl.port,\n      path: '/events'\n    }\n    const req = http.request(options, (res) => {\n      console.log('SSE connection established')\n      let buffer = ''\n      res.on('data', (chunk) => {\n        buffer += chunk.toString()\n        const parts = buffer.split('\\n\\n')\n        buffer = parts.pop()\n        for (const part of parts) {\n          if (part.startsWith('data: ')) {\n            const dataStr = part.substring(6).trim()\n            try {\n              const msg = JSON.parse(dataStr)\n              if (msg.type && this._listeners[msg.type]) {\n                this._emit(msg.type, msg)\n              }\n            } catch (err) {}\n          }\n        }\n      })\n      res.on('end', () => {\n        console.log('SSE connection ended')\n      })\n    })\n    req.on('error', (err) => {\n      console.error('SSE request error:', err)\n    })\n    req.end()\n    this.sseRequest = req\n  }\n\n  async send (message) {\n    if (this.isServer) {\n      if (message.type === 'event') {\n        const data = `data: ${JSON.stringify(message)}\\n\\n`\n        this.eventClients.forEach(client => {\n          client.res.write(data)\n        })\n      }\n      return Promise.resolve()\n    } else {\n      const fetch = require('bare-fetch')\n      try {\n        const res = await fetch(this.clientOptions.url + '/rpc', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(message)\n        })\n        const text = await res.text()\n        let data\n        try {\n          data = JSON.parse(text)\n        } catch (err) {\n          throw new Error('Failed to parse response as JSON: ' + text)\n        }\n        this._emit('response', data)\n        return Promise.resolve(data)\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  close () {\n    if (this.isServer) {\n      if (this.server) {\n        this.server.close()\n      }\n    } else {\n      if (this.sseRequest && typeof this.sseRequest.abort === 'function') {\n        this.sseRequest.abort()\n      }\n    }\n  }\n}\n\nmodule.exports = HTTPTransport\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst BaseTransport = require('./BaseTransport')\n\nclass MobileIPCTransport extends BaseTransport {\n  constructor (opts = {}) {\n    super(opts)\n    if (!opts.IPC) {\n      throw new Error('MobileIPCTransport requires an IPC instance')\n    }\n    this.IPC = opts.IPC\n    this.isServer = !!opts.isServer\n  }\n\n  async start () {\n    if (!this.isServer) {\n      throw new Error('start() should only be called on a server transport')\n    }\n    this.IPC.setEncoding('utf8')\n    this.IPC.on('data', (data) => {\n      try {\n        const msg = JSON.parse(data)\n        if (msg.type && this._listeners[msg.type]) {\n          if (msg.type === 'request' || msg.type === 'subscribe') {\n            this._emit(msg.type, msg, (err, result) => {\n              const response = {\n                type: 'response',\n                id: msg.id,\n                error: err ? err.message : null,\n                result\n              }\n              this.send(response)\n            })\n          } else {\n            this._emit(msg.type, msg)\n          }\n        }\n      } catch (err) {\n        this._emit('error', new Error('Failed to parse message: ' + err.message))\n      }\n    })\n  }\n\n  async connect () {\n    if (this.isServer) {\n      throw new Error('connect() should only be called on a client transport')\n    }\n    this.IPC.setEncoding('utf8')\n    this.IPC.on('data', (data) => {\n      try {\n        const msg = JSON.parse(data)\n        if (msg && msg.type) {\n          this._emit(msg.type, msg)\n        } else {\n          this._emit('message', msg)\n        }\n      } catch (err) {\n        this._emit('error', new Error('Failed to parse message: ' + err.message))\n      }\n    })\n  }\n\n  async send (message) {\n    const data = JSON.stringify(message)\n    this.IPC.write(data)\n    return Promise.resolve()\n  }\n}\n\nmodule.exports = MobileIPCTransport\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst ws = require('bare-ws')\nconst BaseTransport = require('./BaseTransport')\n\nclass WebSocketTransport extends BaseTransport {\n  constructor ({ serverOptions, clientOptions } = {}) {\n    super()\n    this.serverOptions = serverOptions || null\n    this.clientOptions = clientOptions || null\n    this.isServer = !!serverOptions\n    this.ws = null\n    this.server = null\n    this.pendingMessages = []\n  }\n\n  async start () {\n    if (!this.isServer) {\n      throw new Error('start() should only be called on a server transport')\n    }\n    this.server = new ws.Server(this.serverOptions, (socket) => {\n      this.ws = socket\n      socket.on('data', (data) => {\n        let msg\n        try {\n          msg = JSON.parse(data.toString())\n        } catch (err) {\n          return\n        }\n        if (msg.type && this._listeners[msg.type]) {\n          if (msg.type === 'request' || msg.type === 'subscribe') {\n            this._emit(msg.type, msg, (err, result) => {\n              const response = {\n                type: 'response',\n                id: msg.id,\n                error: err ? err.message : null,\n                result\n              }\n              this.send(response)\n            })\n          } else {\n            this._emit(msg.type, msg)\n          }\n        }\n      })\n    })\n    return new Promise((resolve, reject) => {\n      this.server.on('listening', resolve)\n      this.server.on('error', reject)\n    })\n  }\n\n  async connect () {\n    if (this.isServer) {\n      throw new Error('connect() should only be called on a client transport')\n    }\n    if (!this.clientOptions || !this.clientOptions.url) {\n      throw new Error('clientOptions with a valid URL must be provided for client mode')\n    }\n    const { hostname, port } = new URL(this.clientOptions.url)\n    this.ws = new ws.Socket({ hostname, port })\n    this.ws.on('data', (data) => {\n      let msg\n      try {\n        msg = JSON.parse(data.toString())\n      } catch (err) {\n        return\n      }\n      if (msg.type && this._listeners[msg.type]) {\n        this._emit(msg.type, msg)\n      }\n    })\n    return new Promise((resolve, reject) => {\n      this.ws.on('open', resolve)\n      this.ws.on('error', reject)\n    })\n  }\n\n  async send (message) {\n    const data = JSON.stringify(message)\n    if (this.ws) {\n      this.ws.write(data)\n    } else {\n      this.pendingMessages.push(data)\n    }\n    return Promise.resolve()\n  }\n\n  close () {\n    if (this.ws) {\n      this.ws.end()\n    }\n    if (this.server) {\n      this.server.close()\n    }\n  }\n}\n\nmodule.exports = WebSocketTransport\n// Copyright 2025 Tether Operations Limited\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nmodule.exports = {\n  BaseTransport: require('./BaseTransport'),\n  DesktopIPCTransport: require('./DesktopIPCTransport'),\n  MobileIPCTransport: require('./MobileIPCTransport'),\n  HTTPTransport: require('./HTTPTransport'),\n  WebSocketTransport: require('./WebSocketTransport')\n}\n"
